.default= NA))
long_wd %>%
group_by(ssuid_spanel_pnum) %>%
mutate(some_se = sum(employment_type ==2, na.rm = TRUE),
ever_se = ifelse(some_se >0,1,0)) %>%
ungroup() %>%
group_by(ever_se) %>% distinct(ssuid_spanel_pnum) %>% count()
temp <- long_wd %>% group_by(ssuid_spanel_pnum) %>%
mutate(erace_change = erace != first(erace, default= first(erace)),
hispanic_change = hispanic !=first(hispanic, default = first(hispanic))) %>%
ungroup() %>% relocate(ssuid_spanel_pnum,  erace_change, erace, hispanic, hispanic_change)
temp %>% group_by(hispanic_change) %>% distinct(ssuid_spanel_pnum) %>% count()
temp %>% group_by(erace_change) %>% distinct(ssuid_spanel_pnum) %>% count()
long_wd <- long_wd %>%
arrange(ssuid_spanel_pnum, swave, monthcode) %>%
group_by(ssuid_spanel_pnum) %>%
# given above inconsistent reporting of race and ethnicity here we categorize each person based on their first value reported
mutate(erace_std = first(erace),
hispanic_std = first(hispanic)) %>%
ungroup() %>%
# create combined version of race/ethnicity
mutate(race_eth = case_when(hispanic_std == 1 ~ "Hispanic",
erace_std == 1 ~ "White",
erace_std == 2 ~ "Black",
erace_std == 3 ~ "Asian",
erace_std == 4 ~ "Other",
.default = NA),
race_eth_fct = factor(race_eth, levels = c("White", "Black", "Hispanic", "Asian", "Other")),
race_eth_fct_cpsd = fct_collapse(race_eth_fct, White = c("White"), Non_white = c("Black", "Asian", "Hispanic", "Other")),
sex_fct = factor(esex, levels = c(1,2), labels = c("Male", "Female")),
immig_fct = factor(ebornus, levels = c(1,2), labels = c("US Born", "Immigrant")),
# https://www2.census.gov/programs-surveys/sipp/2023/2023_SIPP_Data_Overview_Handout_SEP23.pdf
calyear = case_when(spanel == 2014 & swave == 1 ~ 2013,
spanel == 2014 & swave == 2 ~ 2014,
spanel == 2014 & swave == 3 ~ 2015,
spanel == 2014 & swave == 4 ~ 2016,
spanel == 2018 & swave == 1 ~ 2017,
spanel == 2018 & swave == 2 ~ 2018,
spanel == 2018 & swave == 3 ~ 2019,
spanel == 2018 & swave == 4 ~ 2020,
spanel == 2019 & swave == 1 ~ 2018,
spanel == 2020 & swave == 1 ~ 2019,
spanel == 2020 & swave == 2 ~ 2020,
spanel == 2020 & swave == 3 ~ 2021,
spanel == 2020 & swave == 4 ~ 2022,
spanel == 2021 & swave == 1 ~ 2020,
spanel == 2021 & swave == 2 ~ 2021,
spanel == 2021 & swave == 3 ~ 2022,
spanel == 2022 & swave == 1 ~ 2021,
spanel == 2022 & swave == 2 ~ 2022,
spanel == 2023 & swave == 1 ~ 2022,
.default = NA),
educ_fct = factor(case_when(eeduc >= 43 ~ "4-year Degree or More",
eeduc >= 40 ~ "Some College or Assoc",
eeduc < 40 ~ "HS or Less",
.default = NA), levels = c("HS or Less", "Some College or Assoc", "4-year Degree or More")),
industry_fct = case_when(ind < 570 ~ "Forestry, Farming, Fishing, Hunting, & Mining",
ind == 770 ~ "Construction",
ind >=1070 & ind <=3990 ~ "Manufacturing",
ind >= 4070 & ind <= 4590 ~ "Wholesale Trade",
ind >= 4670 & ind <= 5790 ~ "Retail Trade",
(ind >=6070 & ind <= 6390) | (ind >= 570 & ind <= 690) ~ "Transportation, Warehousing & Utilities",
ind >= 6470 & ind <= 6780 ~ "Information",
ind >= 6870 & ind <= 7190 ~ "Finance and Insurance, and Real Estate, and Rental and Leasing",
ind >= 7270 & ind <= 7790 ~ "Professional, Scientific, and Management, and Administrative, and Waste Management Services",
ind >= 7860 & ind <= 8470  ~ "Educational Services, and Health Care and Social Assistance",
ind >= 8560 & ind <= 8690 ~ "Arts, Entertainment, and Recreation, and Accommodation and Food Services",
ind >= 8770 & ind <= 9290 ~ "Other Services, Except Public Administration",
ind >= 9370 & ind <= 9590  ~ "Public Administration",
ind >= 9890  ~ "Military",
.default = NA),
parent = ifelse(epar_scrnr == 1, 1,
ifelse(epar_scrnr == 2, 0, NA))
)
temp <- long_wd %>%
arrange(ssuid_spanel_pnum, swave, monthcode) %>%
group_by(ssuid_spanel_pnum) %>%
mutate(parent_disappear = parent < first(parent)) %>% ungroup()
monthly %>% filter(ssuid_spanel_pnum == "114285465212021103") %>% select(swave, monthcode, tceb, epar_scrnr) # example of someone with inconsistent parent information within the base data.
temp %>% group_by(parent_disappear) %>% distinct(ssuid_spanel_pnum) %>% count()
temp %>% filter(ssuid_spanel_pnum == "114285465212021103") %>% select(swave, monthcode, tceb, epar_scrnr, parent)
temp <- long_wd %>%
arrange(ssuid_spanel_pnum, swave, monthcode) %>%
group_by(ssuid_spanel_pnum) %>%
mutate(parent_first = first(parent),
parent_last = last(parent)) %>%
# as we saw above some people reported moving from being a parent to being a non-parent, so we can carry that forwards. This is similar to the tceb issue where people reported having biological children in an earlier wave and then report not occurring. Using the epar_scrnr this is 934 people with this disappearing child (could be due to deaths I suppose, but the question seems more general to did they ever have a kid. )
mutate(parent_std= parent,
parent_std = cummax(parent_std)) %>% ungroup()
temp %>% filter(ssuid_spanel_pnum == "114285465212021103") %>% select(swave, monthcode, tceb, epar_scrnr, contains("parent")) %>% print(n = 100)
temp %>% filter(ssuid_spanel_pnum == "2920924180182014101") %>% select(swave, monthcode, tceb, epar_scrnr, contains("parent")) %>% print(n = 100)
long_wd <- long_wd %>%
arrange(ssuid_spanel_pnum, swave, monthcode) %>%
group_by(ssuid_spanel_pnum) %>%
mutate(parent_first = first(parent),
parent_last = last(parent)) %>%
# as we saw above some people reported moving from being a parent to being a non-parent, so we can carry that forwards. This is similar to the tceb issue where people reported having biological children in an earlier wave and then report not occurring. Using the epar_scrnr this is 934 people with this disappearing child (could be due to deaths I suppose, but the question seems more general to did they ever have a kid. )
mutate(parent_std= parent,
parent_std = cummax(parent_std)) %>% ungroup()
full_year_markers <- long_wd %>%
group_by(ssuid_spanel_pnum, swave) %>%
# check that in each wave the person has a full 12 months.
summarize(has_full_year = all(1:12 %in% monthcode)) %>%
ungroup() %>%
# filter to only those waves where a person had 12 months of data.
filter(has_full_year)
full_year_markers %>% filter(ssuid_spanel_pnum %in% c("7178160572292014102", "8818607717842014104"))
# merge this in with only keeping the records that had full years of data.
long_wd <- long_wd %>% inner_join(full_year_markers, by = c("ssuid_spanel_pnum", "swave")) %>%
# make a new months_in_data column now that we've removed partial waves
select(-months_in_data) %>%
group_by(ssuid_spanel_pnum) %>%
mutate(months_in_data = n()) %>% ungroup()
table(long_wd$months_in_data) # confirming we have full years for everyone at this point.
# this function calculates the mode of a set of values and breaks ties by selecting the larger mode. So in our use case we're defaulting towards unemployment if someone had 4 months of SE, 4 months of WS and 4 months of Unemployment we would categorize them as unemployed in that first year based on this funciton.
find_max_mode <- function(x) {
u <- unique(x)
tab <- tabulate(match(x, u))
max(u[tab == max(tab)])
}
mode_statuses <- long_wd %>% select(ssuid_spanel_pnum, swave, monthcode, employment_type) %>%
arrange(ssuid_spanel_pnum, swave, monthcode) %>%
group_by(ssuid_spanel_pnum) %>%
filter(row_number() <=12) %>%
summarize(mode_status = find_max_mode(employment_type))
long_wd <- long_wd %>%
left_join(mode_statuses, by = "ssuid_spanel_pnum") # this adds their mode status during the first year to all records for the individual.
library(data.table)
consec_unemp <- setDT(long_wd)
consec_unemp <- consec_unemp %>%
group_by(ssuid_spanel_pnum) %>%
filter(row_number() <=12) %>%
mutate(
### Gen value of 1 for first run, 2 for second stretch but doesn't filter to only those that are unemployed months
stretch = rleid(enjflag_std),
stretch_workless = ifelse(enjflag_std == 1, stretch, NA ),
is_non_missing = !is.na(stretch_workless), # could recode this with just referencing stretch_workless
spell_id = cumsum(is_non_missing & lag(!is_non_missing, default = TRUE)), # Identify spell groups
spell_length = ifelse(is_non_missing, ave(is_non_missing, ssuid_spanel_pnum, spell_id, FUN = cumsum), 0),
max_consec_unemp = max(spell_length, na.rm=TRUE)) %>%
ungroup()
# checking it captured people correctly.
consec_unemp %>%
filter(ssuid_spanel_pnum %in% c("1288929322014101",
"1142851342014103",
"292418136626182018102",
"114136465182018101",
"114285765192019104")) %>%
select(ssuid_spanel_pnum, monthcode, mwkhrs, employment_type, enjflag_std, max_consec_unemp) %>%
print(n = 100)
consec_unemp_coll <- consec_unemp %>%
group_by(ssuid_spanel_pnum) %>%
summarize(max_consec_unemp = first(max_consec_unemp)) %>%
ungroup()
long_wd <- long_wd %>%
left_join(consec_unemp_coll, by = "ssuid_spanel_pnum")
long_wd <- long_wd %>%
group_by(ssuid_spanel_pnum) %>%
tidylog::filter(!any(mode_status == 3)) %>%
tidylog::filter(!any(industry_fct == "Military", na.rm = TRUE)) %>%
ungroup()
# Take our modal status, but override the mode if someone experienced 3 or more months of unemployment during first year in the data.
y1_statuses <- long_wd %>%
select(ssuid_spanel_pnum, swave, monthcode, employment_type, workless_month, mode_status) %>%
arrange(ssuid_spanel_pnum, swave, monthcode) %>%
group_by(ssuid_spanel_pnum) %>%
filter(row_number() <=12) %>%  # keep each person's first year only.
summarize(unemp_f12 = sum(workless_month, na.rm = TRUE),
mode_status = first(mode_status)) %>%
ungroup() %>%
mutate(y1_status_v2 = ifelse(unemp_f12 >=3, 4,
mode_status))
long_wd <- long_wd %>%
left_join(y1_statuses %>% select(ssuid_spanel_pnum, y1_status_v2, unemp_f12), by = "ssuid_spanel_pnum")
table(long_wd$months_in_data, useNA = "ifany")
long_wd <- long_wd %>%
filter(months_in_data > 12 ) ## really only == 12 here since we've already filterd to only thsoe with full years. We can do this without grouping because we have
se_quantified <- long_wd %>%
arrange(ssuid_spanel_pnum, swave, monthcode) %>%
group_by(ssuid_spanel_pnum) %>%
# get only records after first year
filter(row_number() > 12) %>%
summarize(ft_se_months_py1 = sum(ifelse(mwkhrs >= 15 & employment_type == 2,1,0), na.rm = TRUE),
pt_se_months_py1 = sum(ifelse(mwkhrs < 15 & employment_type == 2,1,0), na.rm = TRUE),
pt_months_py1 = sum(ifelse(mwkhrs < 15,1,0), na.rm = TRUE),
ft_months_py1 = sum(ifelse(mwkhrs >= 15, 1, 0), na.rm = TRUE),
ft_ws_months_py1 = sum(ifelse(mwkhrs >=15 & employment_type == 1,1,0), na.rm = TRUE),
pt_ws_months_py1 = sum(ifelse(mwkhrs < 15 & employment_type == 1,1,0), na.rm = TRUE),
months_after_y1 = max(row_number()),
pct_se_py1_ft = ft_se_months_py1/months_after_y1,
months_employed_py1 = sum(ifelse(employment_type != 4,1,0)),
mean_hrs = mean(mwkhrs, na.rm = TRUE),
se_months_py1 = sum(ifelse(employment_type == 2, 1,0), na.rm = TRUE),
ws_months_py1 = sum(ifelse(employment_type == 1, 1, 0), na.rm = TRUE)
) %>%
ungroup()
almost_ft <- se_quantified %>%
filter(months_after_y1 != ft_months_py1) %>%
select(ssuid_spanel_pnum) %>% as.vector()
## confirming here that these people are actually correctly coded
joblevel_wide %>% filter(ssuid_spanel_pnum %in% almost_ft$ssuid_spanel_pnum) %>%
select(
ssuid_spanel_pnum,
swave,
monthcode,
contains("msum"),
contains("mwkhrs"),-contains("alt"),
contains("jborse")
) %>%
head()
temp_ft_equals_months <- long_wd %>%
left_join(se_quantified, by = "ssuid_spanel_pnum") %>%
group_by(ssuid_spanel_pnum) %>%
filter(row_number() > 12) %>%
ungroup() %>%
# based on the number of people we lose here I think we actually want to allow some flexibility here.
tidylog::filter(months_after_y1 == ft_months_py1)
temp_ft_equals_months %>% select(
ssuid_spanel_pnum,
swave,
monthcode,
months_in_data,
months_after_y1,
ft_months_py1,
months_employed_py1,
workless_month,
enjflag_std,
jobid,
msum,
mwkhrs
) %>% head()
se_quantified %>% filter(ssuid_spanel_pnum == "292092406784182018101") %>% flextable::flextable()
long_wd %>% filter(ssuid_spanel_pnum == "1142851342014101") %>% flextable::flextable() # this person should get filtered out as they have unemployed months after year 1
long_wd %>% filter(ssuid_spanel_pnum == "292092406784182018101") %>% flextable::flextable()
# here we filter to those with employment at least every month post month 12. But we relax the restriction on the need to be full-time employed
# se_sample <- long_wd %>%
#   left_join(se_quantified, by = "ssuid_spanel_pnum") %>%
#   group_by(ssuid_spanel_pnum) %>%
#   # getting rid of first year data as we don't need it for analysis since we already made the flags for their y1 statuses.
#   filter(row_number() > 12) %>%
#   ungroup() %>%
#   # Here we want only those who were continuously employed from month 13 onwards.
#   filter(months_employed_py1 == months_after_y1) %>%
#   # at this point we are safe to use their mean hours worked during months employed to filter out people who were really only in side hustles
#   filter(mean_hrs >= 15) %>%
#   # now we need to filter to those who were only employed in SE
#   filter(se_months_py1 == months_after_y1)
se_sample <- long_wd %>%
left_join(se_quantified, by = "ssuid_spanel_pnum") %>%
group_by(ssuid_spanel_pnum) %>%
mutate(months_employed =sum(ifelse(employment_type != 4,1,0)) ) %>%
filter(row_number() > 12) %>%
ungroup() %>%
# Here we want only those who were continuously employed from month 13 onwards.
filter(months_employed_py1 == months_after_y1) %>%
# at this point we are safe to use their mean hours worked during months employed to filter out people who were really only in side hustles
filter(mean_hrs >= 15) %>%
# now we need to filter to those who were only employed in SE
filter(se_months_py1 == months_after_y1)
full_time_period_flags <- long_wd %>%
arrange(ssuid_spanel_pnum, swave, monthcode) %>%
group_by(ssuid_spanel_pnum) %>%
summarize(ft_se_months = sum(ifelse(mwkhrs >= 15 & employment_type == 2,1,0), na.rm = TRUE),
pt_se_months = sum(ifelse(mwkhrs < 15 & employment_type == 2,1,0), na.rm = TRUE),
pt_months = sum(ifelse(mwkhrs < 15,1,0), na.rm = TRUE),
ft_months = sum(ifelse(mwkhrs >= 15, 1, 0), na.rm = TRUE),
ft_ws_months = sum(ifelse(mwkhrs >=15 & employment_type == 1,1,0), na.rm = TRUE),
pt_ws_months = sum(ifelse(mwkhrs < 15 & employment_type == 1,1,0), na.rm = TRUE),
months = max(row_number()),
pct_se_ft = ft_se_months/months,
pct_ws_ft = ft_ws_months/months,
months_employed = sum(ifelse(employment_type != 4,1,0)),
mean_hrs = mean(mwkhrs, na.rm = TRUE),
se_months = sum(ifelse(employment_type == 2, 1,0), na.rm = TRUE),
ws_months = sum(ifelse(employment_type == 1, 1, 0), na.rm = TRUE)
) %>%
ungroup() %>%
tidylog::filter(months_employed == months) %>%
## now we know these people had at least some employment during each month of our data. So now we filter to those who had an average working hours of >=15 in each month.
tidylog::filter(mean_hrs >=15) %>%
## now we need those who were continuously employed in WS or SE
tidylog::filter(se_months/months == 1 | ws_months/months == 1 ) %>%
mutate(employment_group = case_when(se_months/months == 1 ~ "Self-Employed",
ws_months/months == 1 ~ "Wage & Salary"))
## now with the left-join we'll keep only those we've identified above and get some summary stats on them. Could do this all above, but for clarity will keep it separated in case this gets moved to an analysis script later.
full_time_period_flags %>%
left_join(long_wd, by = "ssuid_spanel_pnum") %>%
#can group by employment_group here to bring it along since it's constant within individuals based on above restrictions
group_by(ssuid_spanel_pnum, calyear, employment_group) %>%
summarize(tpearn = sum(tpearn, na.rm = TRUE),
msum = sum(msum, na.rm = TRUE)) %>%
# the above gets us to yearly values. now we move to person-level summary stats of yearly values
ungroup() %>%
gtsummary::tbl_summary(by = employment_group, include = c(tpearn, msum),
statistic = list( ~ "{mean} [{median}] ({sd})")) %>%
gtsummary::add_overall() %>%
gtsummary::modify_caption("Earnings Comparison, Full-time Workers (Person-Year level)") %>%
gtsummary::as_hux_xlsx(file = paste0("earnings_comparison", Sys.Date(),".xlsx"))
full_time_period_flags %>%
left_join(long_wd, by = "ssuid_spanel_pnum") %>%
group_by(employment_group) %>%
summarize(n_people = n_distinct(ssuid_spanel_pnum),
.groups = "drop")
# feed it a vector to convert to log transform that accounts for negative values
log_transform <- function(x) {
min_x <- min(x)*-1
log(x + min_x + 1)
}
ws_vs_se <- full_time_period_flags %>%
left_join(long_wd, by = "ssuid_spanel_pnum") %>%
group_by(ssuid_spanel_pnum, calyear) %>%
summarize(tpearn = sum(tpearn, na.rm = TRUE),
msum = sum(msum, na.rm = TRUE),
employment_group = last(employment_group),
age = max(tage),
educ_fct = last(educ_fct),
race_eth_fct_cpsd = last(race_eth_fct_cpsd),
sex_fct = last(sex_fct),
immig_fct = last(immig_fct),
parent_std = last(parent_std)) %>%
# the above gets us to yearly values. now we move to person-level summary stats of yearly values
ungroup() %>%
mutate(employment_group_fct = factor(employment_group, levels = c("Wage & Salary", "Self-Employed")),
ln_tpearn = log_transform(tpearn),
ln_msum = log_transform(msum))
library(plm)
plm_msum <- plm(ln_msum ~ employment_group_fct  +
calyear ,
data = ws_vs_se,
index = c("ssuid_spanel_pnum", "calyear"),
model = "random")
plm_msum2 <- plm(ln_msum ~ employment_group_fct +
age +
I(age^2) +
educ_fct +
race_eth_fct_cpsd +
sex_fct +
immig_fct +
factor(parent_std) +
calyear,
data = ws_vs_se,
index = c("ssuid_spanel_pnum", "calyear"),
model = "random")
plm_tpearn <- plm(ln_tpearn ~ employment_group_fct  +
calyear ,
data = ws_vs_se,
index = c("ssuid_spanel_pnum", "calyear"),
model = "random")
plm_tpearn2 <- plm(ln_tpearn ~ employment_group_fct +
age +
I(age^2) +
educ_fct +
race_eth_fct_cpsd +
sex_fct +
immig_fct +
factor(parent_std) +
calyear,
data = ws_vs_se,
index = c("ssuid_spanel_pnum", "calyear"),
model = "random")
library(modelsummary)
ws_vs_se_table <- modelsummary(list(plm_msum,
plm_msum2,
plm_tpearn,
plm_tpearn2),
coef_rename = TRUE,
estimate = "{estimate} ({std.error}){stars}",
vcov = "robust",
statistic = NULL,
title = "Table XX Robust SE Employment Type predciting Log Annual Earnings",
output = "gt")
ws_vs_se_table
library(openxlsx)
wb <- createWorkbook()
addWorksheet(wb, "Wage vs SE earnings")
writeData(wb, ws_vs_se_table, sheet = "Wage vs SE earnings")
saveWorkbook(wb, paste0("working_paper_outputs_prep",Sys.Date(),".xlsx"), overwrite = TRUE)
se_sample.5 <- long_wd %>%
left_join(se_quantified, by = "ssuid_spanel_pnum") %>%
group_by(ssuid_spanel_pnum) %>%
# getting rid of first year data as we don't need it for analysis since we already made the flags for their y1 statuses.
filter(row_number() > 12) %>%
ungroup() %>%
# Here we want only those who were continuously employed from month 13 onwards.
filter(months_employed_py1 == months_after_y1) %>%
# at this point we are safe to use their mean hours worked during months employed to filter out people who were really only in side hustles. We're safe to use it now because the mean_hrs calc ignores NA months so wouldn't be valid if we still had NA months post 12 but we don't based on the above filter of continuously employed.
filter(mean_hrs >= 15) %>%
# now we need to filter to those who were only employed in SE
filter(se_months_py1/months_after_y1 >=.5)
se_sample %>%
select(ssuid_spanel_pnum,
swave,
spanel,
monthcode,
race_eth_fct_cpsd,
sex_fct,
immig_fct,
calyear,
educ_fct,
industry_fct,
parent_std,
unemp_f12,
y1_status_v2,
mode_status,
max_consec_unemp,
employment_type,
tpearn, msum, prftb, val,
thval_home, tval_ast, tval_home, thval_ast, eawbmort, eawbgas, rhlthmth,
thcyincpov,thcyincpovt2 ) %>%
naniar::gg_miss_var()
se_sample <- se_sample %>%
filter(if_all(
c(
ssuid_spanel_pnum,
swave,
spanel,
monthcode,
race_eth_fct_cpsd,
sex_fct,
immig_fct,
calyear,
educ_fct,
industry_fct,
parent_std,
unemp_f12,
y1_status_v2,
mode_status,
max_consec_unemp,
employment_type,
#val,
msum,
tpearn,
prftb,
eawbmort,
eawbgas,
rhlthmth,
rfoods,
rfoodr,
thcyincpov,
thcyincpovt2
),
~ !is.na(.)
))
se_sample.5 <- se_sample.5 %>%
# because we allow for .5 SE here there will be records for jobs that were not SE and will therefore be msising for prtb in that row despite that person having another record with prftb equal to a valid value. So we fill those in before deleting missings here
group_by(ssuid_spanel_pnum, calyear) %>%
fill(prftb, .direction = "downup") %>%
ungroup() %>%
filter(if_all(
c(
ssuid_spanel_pnum,
swave,
spanel,
monthcode,
race_eth_fct_cpsd,
sex_fct,
immig_fct,
calyear,
educ_fct,
industry_fct,
parent_std,
unemp_f12,
y1_status_v2,
mode_status,
max_consec_unemp,
employment_type,
#val,
msum,
tpearn,
prftb,
eawbmort,
eawbgas,
rhlthmth,
rfoodr,
rfoods,
thcyincpov,
thcyincpovt2
),
~ !is.na(.)
))
se_sample <- se_sample %>%
mutate(profposi = ifelse(prftb > 0, 1, 0),
prof10k = ifelse(prftb >= 10000, 1, 0)
)
se_sample.5 <- se_sample.5 %>%
mutate(profposi = ifelse(prftb > 0, 1, 0),
prof10k = ifelse(prftb >= 10000, 1, 0)
)
se_sample %>%
select(ssuid_spanel_pnum, swave, monthcode, jobid, mwkhrs, msum, tpearn,
prftb, employment_type, enjflag_std, val, tptotinc, tage,thnetworth, thval_ast ) %>%
filter(ssuid_spanel_pnum %in% c("285049440182018101"))  %>%
flextable::flextable()
se_sample %>%
select(ssuid_spanel_pnum, swave,jobid,  monthcode, mwkhrs, msum, tpearn,
prftb, employment_type, val, tptotinc, tage,thnetworth, thval_ast ) %>%
filter(ssuid_spanel_pnum %in% c("292136334552182018102"))  %>%
flextable::flextable()
se_sample %>% filter(mwkhrs > 0 & tpearn == 0 & msum == 0 & tptotinc == 0 & prftb == 0 ) %>% distinct(ssuid_spanel_pnum) %>% count()
se_sample %>% filter(mwkhrs > 0 & tpearn == 0 & msum == 0 & tptotinc == 0 & prftb == 0 & thnetworth < 50000) %>% distinct(ssuid_spanel_pnum) %>% count()
se_sample %>% filter(mwkhrs == 0) %>% distinct(ssuid_spanel_pnum) %>% count()
se_sample %>% group_by(ssuid_spanel_pnum) %>% summarize(months_0workhours = sum(mwkhrs == 0), months = n()) %>% arrange(desc(months_0workhours))
se_sample %>% filter(is.na(val)) %>% distinct(ssuid_spanel_pnum) %>% count()
se_sample_cleanest <- se_sample %>%
group_by(ssuid_spanel_pnum) %>%
filter(all(mwkhrs != 0)) %>%
filter(!any(mwkhrs > 0 & tpearn == 0 & msum == 0 & tptotinc == 0 & prftb == 0)) %>% ungroup()
se_sample.5_cleanest <- se_sample.5 %>%
group_by(ssuid_spanel_pnum) %>%
filter(all(mwkhrs != 0)) %>%
filter(!any(mwkhrs > 0 & tpearn == 0 & msum == 0 & tptotinc == 0 & prftb == 0)) %>%
ungroup()
