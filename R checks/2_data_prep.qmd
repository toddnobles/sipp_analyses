---
title: "SIPP Analyses Script 2 Data Prep and Sample Creation"
format: 
  html:
    toc: true
    toc-depth: 5
    embed-resources: true

execute:
  echo: true
  message: false
  warning: false
---

This is the second script in the process for recreating the Stata anaylses for the SIPP data. This script reads in the SIPP files produced by the 1_data_intake.R script, extracts relevant work/income variables, reshapes the person-month-job variables to align to the person-month variables.

```{r, message = FALSE, warning = FALSE}
rm(list=ls())
library(tidyverse)
library(bit64)
library(tidylog)
```

```{r load data}
monthly <- readRDS("/Volumes/ExtremeSSD/SIPP Data Files/rds/sipp_monthly_combined.rds")
joblevel_wide <- readRDS("/Volumes/ExtremeSSD/SIPP Data Files/rds/sipp_joblevel_combined_wide.rds") 

```

Bring in the monthly/yearly level variables and the joblevel data and create ids for them. We could just use ssuid and pnum but being extra careful here including the spanel in case the SIPP ever reused an ssuid + pnum combo across panels.

```{r create ids}
monthly <- monthly %>% mutate(
  ssuid = as.character.integer64(ssuid),
  ssuid_spanel_pnum = paste0(
        ssuid,
        as.character(spanel),
        as.character(pnum)
      ))


joblevel_wide <- joblevel_wide %>% mutate(
  ssuid = as.character.integer64(ssuid),
  ssuid_spanel_pnum = paste0(
        ssuid,
        as.character(spanel),
        as.character(pnum)
      )
)
```

Here we impute those instances where someone had all of the earnings and job information we care about but did not have a jobid value for that specific job. Because we conduct later analyses at the month level we don't particularly care if this job is just an uncoded version of ejobid 101 , 102, 103 for instance. Put differently, it's unclear from the data quality flags (ajb\_ vars) why these are "not in universe" for jobid, but the records contain all the information we'd want so we can impute some fictional jobids. We lose the ability to track if these are the same jobs they held before/after that month but we aren't concerned with that.

```{r data preview for imputation }
joblevel_wide %>% filter(ssuid == "418209316" & pnum == 102) %>% select(ssuid_spanel_pnum, ssuid, pnum, monthcode, contains("enjflag"), contains("jborse"), contains("jobid"), contains("msum"), contains("prftb"), contains("mwkhrs"), contains("ind")) %>% flextable::flextable()
```

```{r imputing jobids}
joblevel_wide <- joblevel_wide %>% 
  select(
      'ssuid',
      'spanel',
      'swave',
      'pnum',
      'monthcode',
      'ssuid_spanel_pnum',
      contains("prftb"),
      contains("msum"),
      contains("mwkhrs"),
      contains("jborse"),
      contains("jobid"),
      contains("ind"),
      contains("tbsj")) %>%
    tidylog::mutate(
      ejb1_jobid = ifelse(
        is.na(ejb1_jobid) & !is.na(tjb1_mwkhrs) & !is.na(ejb1_jborse) &
          (!is.na(tjb1_msum) | !is.na(tjb1_prftb)),
        1,
        ejb1_jobid
      ),
      ejb2_jobid = ifelse(
        is.na(ejb2_jobid) & !is.na(tjb2_mwkhrs) & !is.na(ejb2_jborse) &
          (!is.na(tjb2_msum) |
             !is.na(tjb2_prftb)),
        2,
        ejb2_jobid
      ),
      ejb3_jobid = ifelse(
        is.na(ejb3_jobid) & !is.na(tjb3_mwkhrs) & !is.na(ejb3_jborse) &
          (!is.na(tjb3_msum) |
             !is.na(tjb3_prftb)),
        3,
        ejb3_jobid
      ),
      ejb4_jobid = ifelse(
        is.na(ejb4_jobid) & !is.na(tjb4_mwkhrs) & !is.na(ejb4_jborse) &
          (!is.na(tjb4_msum) |
             !is.na(tjb4_prftb)),
        4,
        ejb4_jobid
      ),
      ejb5_jobid = ifelse(
        is.na(ejb5_jobid) & !is.na(tjb5_mwkhrs) & !is.na(ejb5_jborse) &
          (!is.na(tjb5_msum) |
             !is.na(tjb5_prftb)),
        5,
        ejb5_jobid
      ),
      ejb6_jobid = ifelse(
        is.na(ejb6_jobid) & !is.na(tjb6_mwkhrs) & !is.na(ejb6_jborse) &
          (!is.na(tjb6_msum) |
             !is.na(tjb6_prftb)),
        6,
        ejb6_jobid
      ),
      ejb7_jobid = ifelse(
        is.na(ejb7_jobid) & !is.na(tjb7_mwkhrs) & !is.na(ejb7_jborse) &
          (!is.na(tjb7_msum) |
             !is.na(tjb7_prftb)),
        7,
        ejb7_jobid
      )
    )

```

Next we combine the monthly level dataframe with the wide joblevel file.

```{r combining to joblevel and monthly into dataframe}
full_data_base <- tidylog::left_join(monthly, joblevel_wide, 
                                     by = c("ssuid_spanel_pnum", "spanel", "swave", "monthcode"))
```
Then we filter to the working age population based on age at entry into dataset.


```{r filtering to working age sample by age at entry}
full_data <- full_data_base %>% 
  group_by(ssuid_spanel_pnum) %>% 
  mutate(age_entry = min(tage),
         age_exit = max(tage)) %>% 
  filter(age_entry >= 18 & age_entry <= 64) %>% ungroup()
```

They changed the cooding of the unemployment flag (enjflag) between panels, so correcting for that here.

```{r standardizing enjflag unemployment flag}
# Unemployment flag is 0 = not unemployed and 1 = unemployed for 2014 panel. Then switches to 2 = not unemployed and 1 = unemployed for 2018 onwards. So recoding accordingly here 
full_data <- full_data %>% 
  mutate(enjflag_std = ifelse(spanel == 2014 & enjflag == 1, 1,
                              ifelse(spanel >2014 & enjflag == 1, 1,
                                     ifelse(enjflag == 0 | enjflag == 2, 0, NA)))) 
```

Dropping those who never worked.

```{r removing those who never worked}
full_data <- full_data %>% 
  mutate(workless_month = if_all(starts_with("ejb") & ends_with("jobid"), is.na)) %>% 
  mutate(workless_month = ifelse(workless_month, 1, 0)) %>% 
  group_by(ssuid_spanel_pnum) %>% 
  mutate(months_in_data = n(),
         workless_month_tot = sum(workless_month)) %>%
  ungroup() %>% 
  tidylog::filter(months_in_data > workless_month_tot) 

```

Now we need to mark their main job based on number of hours worked and keep only that row for the month.To do that we first do some renaming to make the reshaping easier. Then we reshape the job variables to long format. This is done once and then saved out as it's fairly computationally intensive.

```{r }
full_data <- full_data %>% 
  tidylog::select(-ends_with(".y"), -starts_with("ajb")) %>% 
  rename_with(
    ~ gsub("^(tbsj\\d+)(val)$", "\\1_\\2", .), # adding in underscore to match the name formatting of tjb and ejb variables for easier reshaping
    starts_with("tbsj")
  ) 
```

```{r reshaping joblevel to long, include = FALSE, eval = FALSE}
# this reshaping only needs to run if the underlying data change. Due to time it takes to run I'm leaving it unread here 
ptm <- proc.time()

long <- full_data %>% 
  pivot_longer(
    cols = matches("^(tjb|ejb|tbsj)\\d+_"),  
    names_to = c("job", ".value"),     
    names_pattern = "^[a-z]+(\\d+)_(.*)$" 
  ) %>% group_by(ssuid_spanel_pnum, swave, monthcode) %>% 
  relocate(ssuid_spanel_pnum, swave, monthcode, jobid, mwkhrs, msum) %>% 
  slice_max(mwkhrs, with_ties = FALSE) %>% ungroup()
proc.time() - ptm
saveRDS(long, "/Volumes/ExtremeSSD/SIPP Data Files/rds/sipp_long_2014_2023.rds")
```

```{r}
long <- readRDS("/Volumes/ExtremeSSD/SIPP Data Files/rds/sipp_long_2014_2023.rds")
```

Here we create a long_wd working dataset and leave the above dataset as a ground truth for data checks. Next we turn to create flags for the type of employment in each month. 1 = WS, 2 = SE, 3 = Other, and 4 = unemployed.

```{r create long_wd for leaving original long dataframe as reference}
long_wd <- long %>% 
  mutate(employment_type = case_when(jborse ==1 ~  1,
                                     jborse == 2 ~ 2,
                                     jborse == 3 ~ 3,
                                     is.na(jborse) & enjflag_std == 1 ~ 4,
                                     .default = NA)) %>%  # this creates ~300 NAs, where they have no job data for their main job but they don't get flagged as unemployed spell in the enjflag data. So we'll impute unemployment here for these months. 
  tidylog::mutate(employment_type = ifelse(is.na(employment_type), 4, employment_type)) %>% 
  tidylog::mutate(hispanic = case_when(eorigin == 1 ~ 1,
                                      eorigin == 2 ~ 0,
                                      .default= NA)) 


```




## June 2025 update to add n-counts for all those who ever had any SE in the base SIPP
So this is looking at main job but is already filtered by age to working age population 
```{r}
long_wd %>% 
  group_by(ssuid_spanel_pnum) %>% 
  mutate(some_se = sum(employment_type ==2, na.rm = TRUE),
         ever_se = ifelse(some_se >0,1,0)) %>% 
  ungroup() %>% 
  group_by(ever_se) %>% distinct(ssuid_spanel_pnum) %>% count()
  
```


In the Stata analysis I noticed some issues with the sipp data having inconsistent race/ethnicity variables. Here again, as in the Stata version, we correct for this and impute the first race/eth reported forwards.

For example, 378 people changed their response to whether or not they were hispanic during the course of their survey participation. Likewise, 1747 people changed their response to their race question during the course of the survey.

```{r investigate inconsistent race and ethnicity}
temp <- long_wd %>% group_by(ssuid_spanel_pnum) %>% 
  mutate(erace_change = erace != first(erace, default= first(erace)),
         hispanic_change = hispanic !=first(hispanic, default = first(hispanic))) %>% 
  ungroup() %>% relocate(ssuid_spanel_pnum,  erace_change, erace, hispanic, hispanic_change) 

temp %>% group_by(hispanic_change) %>% distinct(ssuid_spanel_pnum) %>% count()
temp %>% group_by(erace_change) %>% distinct(ssuid_spanel_pnum) %>% count()
```

Now we restart the recoding of demographic variables to analysis ready versions with labels etc.

```{r recoding demographic variables}
long_wd <- long_wd %>% 
  arrange(ssuid_spanel_pnum, swave, monthcode) %>% 
  group_by(ssuid_spanel_pnum) %>% 
  # given above inconsistent reporting of race and ethnicity here we categorize each person based on their first value reported
  mutate(erace_std = first(erace),
         hispanic_std = first(hispanic)) %>% 
  ungroup() %>% 
  # create combined version of race/ethnicity
  mutate(race_eth = case_when(hispanic_std == 1 ~ "Hispanic",
                              erace_std == 1 ~ "White", 
                              erace_std == 2 ~ "Black", 
                              erace_std == 3 ~ "Asian",
                              erace_std == 4 ~ "Other",
                              .default = NA),
         race_eth_fct = factor(race_eth, levels = c("White", "Black", "Hispanic", "Asian", "Other")),
         race_eth_fct_cpsd = fct_collapse(race_eth_fct, White = c("White"), Non_white = c("Black", "Asian", "Hispanic", "Other")),
         sex_fct = factor(esex, levels = c(1,2), labels = c("Male", "Female")),
         immig_fct = factor(ebornus, levels = c(1,2), labels = c("US Born", "Immigrant")),
        # https://www2.census.gov/programs-surveys/sipp/2023/2023_SIPP_Data_Overview_Handout_SEP23.pdf
         calyear = case_when(spanel == 2014 & swave == 1 ~ 2013, 
                             spanel == 2014 & swave == 2 ~ 2014,
                             spanel == 2014 & swave == 3 ~ 2015, 
                             spanel == 2014 & swave == 4 ~ 2016, 
                             
                             spanel == 2018 & swave == 1 ~ 2017,
                             spanel == 2018 & swave == 2 ~ 2018,
                             spanel == 2018 & swave == 3 ~ 2019, 
                             spanel == 2018 & swave == 4 ~ 2020, 
                             
                             spanel == 2019 & swave == 1 ~ 2018,
                             
                             spanel == 2020 & swave == 1 ~ 2019,
                             spanel == 2020 & swave == 2 ~ 2020,
                             spanel == 2020 & swave == 3 ~ 2021, 
                             spanel == 2020 & swave == 4 ~ 2022,
                             
                             spanel == 2021 & swave == 1 ~ 2020,
                             spanel == 2021 & swave == 2 ~ 2021,
                             spanel == 2021 & swave == 3 ~ 2022,
                             
                             spanel == 2022 & swave == 1 ~ 2021,
                             spanel == 2022 & swave == 2 ~ 2022,
                             
                             spanel == 2023 & swave == 1 ~ 2022,
                             .default = NA),
         educ_fct = factor(case_when(eeduc >= 43 ~ "4-year Degree or More",
                              eeduc >= 40 ~ "Some College or Assoc",
                              eeduc < 40 ~ "HS or Less", 
                              .default = NA), levels = c("HS or Less", "Some College or Assoc", "4-year Degree or More")),
         industry_fct = case_when(ind < 570 ~ "Forestry, Farming, Fishing, Hunting, & Mining",
                                  ind == 770 ~ "Construction",
                                  ind >=1070 & ind <=3990 ~ "Manufacturing",
                                  ind >= 4070 & ind <= 4590 ~ "Wholesale Trade",
                                  ind >= 4670 & ind <= 5790 ~ "Retail Trade",
                                  (ind >=6070 & ind <= 6390) | (ind >= 570 & ind <= 690) ~ "Transportation, Warehousing & Utilities",
                                  ind >= 6470 & ind <= 6780 ~ "Information",
                                  ind >= 6870 & ind <= 7190 ~ "Finance and Insurance, and Real Estate, and Rental and Leasing",
                                  ind >= 7270 & ind <= 7790 ~ "Professional, Scientific, and Management, and Administrative, and Waste Management Services",
                                  ind >= 7860 & ind <= 8470  ~ "Educational Services, and Health Care and Social Assistance",
                                  ind >= 8560 & ind <= 8690 ~ "Arts, Entertainment, and Recreation, and Accommodation and Food Services",
                                  ind >= 8770 & ind <= 9290 ~ "Other Services, Except Public Administration",
                                  ind >= 9370 & ind <= 9590  ~ "Public Administration",
                                  ind >= 9890  ~ "Military",
                                  .default = NA), 
         parent = ifelse(epar_scrnr == 1, 1, 
                         ifelse(epar_scrnr == 2, 0, NA))
         
         
  )
```

Similar to the race/ethnicity inconsistent coding, the parent variable has instances where someone flips from being a parent to not being a parent (at a scale that seems unlikely in the US mortality context). Obviously someone could go from not being a parent to being a parent, but we have people go from being a parent to not being a parent, using either of the parent variables we have (tceb or epar_scrnr). Really we're most interested in if they have a dependent child but we use this measure and impute forwards if someone ever reported having a child.

```{r}
temp <- long_wd %>% 
  arrange(ssuid_spanel_pnum, swave, monthcode) %>%  
  group_by(ssuid_spanel_pnum) %>% 
  mutate(parent_disappear = parent < first(parent)) %>% ungroup()

monthly %>% filter(ssuid_spanel_pnum == "114285465212021103") %>% select(swave, monthcode, tceb, epar_scrnr) # example of someone with inconsistent parent information within the base data. 

temp %>% group_by(parent_disappear) %>% distinct(ssuid_spanel_pnum) %>% count()
temp %>% filter(ssuid_spanel_pnum == "114285465212021103") %>% select(swave, monthcode, tceb, epar_scrnr, parent)
```

Continuing work from the last chunk with examining what is going on with the parent variables in the data.

```{r}
temp <- long_wd %>% 
  arrange(ssuid_spanel_pnum, swave, monthcode) %>% 
  group_by(ssuid_spanel_pnum) %>% 
  mutate(parent_first = first(parent),
         parent_last = last(parent)) %>% 
  # as we saw above some people reported moving from being a parent to being a non-parent, so we can carry that forwards. This is similar to the tceb issue where people reported having biological children in an earlier wave and then report not occurring. Using the epar_scrnr this is 934 people with this disappearing child (could be due to deaths I suppose, but the question seems more general to did they ever have a kid. )
  mutate(parent_std= parent,
         parent_std = cummax(parent_std)) %>% ungroup()

temp %>% filter(ssuid_spanel_pnum == "114285465212021103") %>% select(swave, monthcode, tceb, epar_scrnr, contains("parent")) %>% print(n = 100)
temp %>% filter(ssuid_spanel_pnum == "2920924180182014101") %>% select(swave, monthcode, tceb, epar_scrnr, contains("parent")) %>% print(n = 100)

```

```{r imputing parental status}
long_wd <- long_wd %>% 
  arrange(ssuid_spanel_pnum, swave, monthcode) %>% 
  group_by(ssuid_spanel_pnum) %>% 
  mutate(parent_first = first(parent),
         parent_last = last(parent)) %>% 
  # as we saw above some people reported moving from being a parent to being a non-parent, so we can carry that forwards. This is similar to the tceb issue where people reported having biological children in an earlier wave and then report not occurring. Using the epar_scrnr this is 934 people with this disappearing child (could be due to deaths I suppose, but the question seems more general to did they ever have a kid. )
  mutate(parent_std= parent,
         parent_std = cummax(parent_std)) %>% ungroup() 
```


## Filtering to those with full years of data.

Representative examples to check, so this person 7178160572292014102 has 17 months in the data, and this person has three 8818607717842014104. We want to lose them both and end up with only those who we observe for a full 12 months in each wave.

```{r filtering to only those with full years of data}
full_year_markers <- long_wd %>% 
  group_by(ssuid_spanel_pnum, swave) %>% 
  # check that in each wave the person has a full 12 months. 
  summarize(has_full_year = all(1:12 %in% monthcode)) %>%
  ungroup() %>% 
  # filter to only those waves where a person had 12 months of data. 
  filter(has_full_year) 

full_year_markers %>% filter(ssuid_spanel_pnum %in% c("7178160572292014102", "8818607717842014104"))

# merge this in with only keeping the records that had full years of data. 
long_wd <- long_wd %>% inner_join(full_year_markers, by = c("ssuid_spanel_pnum", "swave")) %>% 
  # make a new months_in_data column now that we've removed partial waves
  select(-months_in_data) %>% 
  group_by(ssuid_spanel_pnum) %>% 
  mutate(months_in_data = n()) %>% ungroup()

table(long_wd$months_in_data) # confirming we have full years for everyone at this point. 
```

Next we need to establish their frist year statuses so that we can group people according to how they're entering into SE.

```{r function to find max mode}
# this function calculates the mode of a set of values and breaks ties by selecting the larger mode. So in our use case we're defaulting towards unemployment if someone had 4 months of SE, 4 months of WS and 4 months of Unemployment we would categorize them as unemployed in that first year based on this funciton. 
find_max_mode <- function(x) {
  u <- unique(x)
  tab <- tabulate(match(x, u))
  max(u[tab == max(tab)]) 
}
```

```{r capturing first year status}
mode_statuses <- long_wd %>% select(ssuid_spanel_pnum, swave, monthcode, employment_type) %>% 
  arrange(ssuid_spanel_pnum, swave, monthcode) %>% 
  group_by(ssuid_spanel_pnum) %>% 
  filter(row_number() <=12) %>% 
  summarize(mode_status = find_max_mode(employment_type)) 

long_wd <- long_wd %>% 
  left_join(mode_statuses, by = "ssuid_spanel_pnum") # this adds their mode status during the first year to all records for the individual. 
```

We're also interested in the consecutive months of unemployment, not just when unemployment is most common status.

A note on the unemployment measures. Our unemployment flag is based on enjflag variable which captures if during the month they had any period of unemployment. However, this period does not have to be a full month of unemployment. We previously used this variable equaling 1 as a flag for unemployment. We still use this, but given our new rule that allows for people to keep months where employment hours were less than 15 we have months where someone can be flagged as unemployed and still report earnings. This is a better reflection of reality, but wanted to raise it as a minor change.

```{r creating max_consec uneployment measure}
library(data.table)
consec_unemp <- setDT(long_wd)
consec_unemp <- consec_unemp %>% 
  group_by(ssuid_spanel_pnum) %>% 
  filter(row_number() <=12) %>% 
  mutate(
    ### Gen value of 1 for first run, 2 for second stretch but doesn't filter to only those that are unemployed months
    stretch = rleid(enjflag_std),
    stretch_workless = ifelse(enjflag_std == 1, stretch, NA ),
    is_non_missing = !is.na(stretch_workless), # could recode this with just referencing stretch_workless
    spell_id = cumsum(is_non_missing & lag(!is_non_missing, default = TRUE)), # Identify spell groups
    spell_length = ifelse(is_non_missing, ave(is_non_missing, ssuid_spanel_pnum, spell_id, FUN = cumsum), 0),
    max_consec_unemp = max(spell_length, na.rm=TRUE)) %>%
  ungroup()


# checking it captured people correctly. 
consec_unemp %>% 
  filter(ssuid_spanel_pnum %in% c("1288929322014101", 
                                  "1142851342014103", 
                                  "292418136626182018102",
                                  "114136465182018101", 
                                  "114285765192019104")) %>% 
  select(ssuid_spanel_pnum, monthcode, mwkhrs, employment_type, enjflag_std, max_consec_unemp) %>%
  print(n = 100)

consec_unemp_coll <- consec_unemp %>% 
  group_by(ssuid_spanel_pnum) %>% 
  summarize(max_consec_unemp = first(max_consec_unemp)) %>% 
  ungroup()
```


```{r merging in unemployment streak measure  }
long_wd <- long_wd %>% 
  left_join(consec_unemp_coll, by = "ssuid_spanel_pnum")
```

We decided to exclud those in the military and those who were ever employed as "other" employment type. So I drop those here.

```{r filtering out those who started out as other employment as modal status}
long_wd <- long_wd %>% 
  group_by(ssuid_spanel_pnum) %>% 
  tidylog::filter(!any(mode_status == 3)) %>% 
  tidylog::filter(!any(industry_fct == "Military", na.rm = TRUE)) %>% 
  ungroup()

```

Next we create our more generous measure of unemployment where even if unemployment wasn't the modal status during the first year, if they experienced a period of 3 months of unemployment we mark them as unemployed during their first year.

```{r replicating y1_status_v2 from stata script}
# Take our modal status, but override the mode if someone experienced 3 or more months of unemployment during first year in the data. 
y1_statuses <- long_wd %>% 
  select(ssuid_spanel_pnum, swave, monthcode, employment_type, workless_month, mode_status) %>% 
  arrange(ssuid_spanel_pnum, swave, monthcode) %>% 
  group_by(ssuid_spanel_pnum) %>% 
  filter(row_number() <=12) %>%  # keep each person's first year only. 
  summarize(unemp_f12 = sum(workless_month, na.rm = TRUE),
            mode_status = first(mode_status)) %>%
  ungroup() %>% 
  mutate(y1_status_v2 = ifelse(unemp_f12 >=3, 4,
                                  mode_status)) 

```

Joining the new measure of y1 status to the main working dataframe.

```{r}
long_wd <- long_wd %>% 
  left_join(y1_statuses %>% select(ssuid_spanel_pnum, y1_status_v2, unemp_f12), by = "ssuid_spanel_pnum")
```

Dropping those we only have one year of data for as we won't be able to set their baseline entry status and then observe any earnings.

```{r dropping those we only have one year of data on}
table(long_wd$months_in_data, useNA = "ifany")
long_wd <- long_wd %>% 
  filter(months_in_data > 12 ) ## really only == 12 here since we've already filterd to only thsoe with full years. We can do this without grouping because we have 
```

Here I create measures of the number of months people held each employment status and number of hours.

```{r}
se_quantified <- long_wd %>% 
  arrange(ssuid_spanel_pnum, swave, monthcode) %>% 
  group_by(ssuid_spanel_pnum) %>%
   # get only records after first year
  filter(row_number() > 12) %>% 
  summarize(ft_se_months_py1 = sum(ifelse(mwkhrs >= 15 & employment_type == 2,1,0), na.rm = TRUE),
         pt_se_months_py1 = sum(ifelse(mwkhrs < 15 & employment_type == 2,1,0), na.rm = TRUE),
         pt_months_py1 = sum(ifelse(mwkhrs < 15,1,0), na.rm = TRUE),
         ft_months_py1 = sum(ifelse(mwkhrs >= 15, 1, 0), na.rm = TRUE),
         ft_ws_months_py1 = sum(ifelse(mwkhrs >=15 & employment_type == 1,1,0), na.rm = TRUE),
         pt_ws_months_py1 = sum(ifelse(mwkhrs < 15 & employment_type == 1,1,0), na.rm = TRUE),
         months_after_y1 = max(row_number()),
         pct_se_py1_ft = ft_se_months_py1/months_after_y1,
         months_employed_py1 = sum(ifelse(employment_type != 4,1,0)),
         mean_hrs = mean(mwkhrs, na.rm = TRUE),
         se_months_py1 = sum(ifelse(employment_type == 2, 1,0), na.rm = TRUE),
         ws_months_py1 = sum(ifelse(employment_type == 1, 1, 0), na.rm = TRUE)
         ) %>% 
  ungroup()



```

```{r}
almost_ft <- se_quantified %>%
  filter(months_after_y1 != ft_months_py1) %>%
  select(ssuid_spanel_pnum) %>% as.vector()


## confirming here that these people are actually correctly coded
joblevel_wide %>% filter(ssuid_spanel_pnum %in% almost_ft$ssuid_spanel_pnum) %>%
  select(
    ssuid_spanel_pnum,
    swave,
    monthcode,
    contains("msum"),
    contains("mwkhrs"),-contains("alt"),
    contains("jborse")
  ) %>%
  head()




temp_ft_equals_months <- long_wd %>%
  left_join(se_quantified, by = "ssuid_spanel_pnum") %>%
  group_by(ssuid_spanel_pnum) %>%
  filter(row_number() > 12) %>%
  ungroup() %>%
  # based on the number of people we lose here I think we actually want to allow some flexibility here.
  tidylog::filter(months_after_y1 == ft_months_py1)


temp_ft_equals_months %>% select(
  ssuid_spanel_pnum,
  swave,
  monthcode,
  months_in_data,
  months_after_y1,
  ft_months_py1,
  months_employed_py1,
  workless_month,
  enjflag_std,
  jobid,
  msum,
  mwkhrs
) %>% head()
```

What do we do about the people like ssuid_spanel_pnum == "292092406784182018101" who are in our data for 48 months, and we use their first year to establish their status, then during the following 36 months, we previously would've lost them due to their work-hours not always being \>= 15. But for this person, that decrease in work hours is only for one month. In other words, for 35 out of 36 months we're looking at their earnings they have a full-time job but only one where they work fewer than 15 hours.

**Filter to only those with months_employed_py1 == months_after_y1, then filter to those with se as \>.5 percent of the months after that and then to account for side-hustles filter to their mean working hours as \>15.**

```{r}
se_quantified %>% filter(ssuid_spanel_pnum == "292092406784182018101") %>% flextable::flextable()
long_wd %>% filter(ssuid_spanel_pnum == "1142851342014101") %>% flextable::flextable() # this person should get filtered out as they have unemployed months after year 1

long_wd %>% filter(ssuid_spanel_pnum == "292092406784182018101") %>% flextable::flextable()
```

```{r filtering to our SE sample}
# here we filter to those with employment at least every month post month 12. But we relax the restriction on the need to be full-time employed 

# se_sample <- long_wd %>%
#   left_join(se_quantified, by = "ssuid_spanel_pnum") %>%
#   group_by(ssuid_spanel_pnum) %>%
#   # getting rid of first year data as we don't need it for analysis since we already made the flags for their y1 statuses.
#   filter(row_number() > 12) %>%
#   ungroup() %>%
#   # Here we want only those who were continuously employed from month 13 onwards.
#   filter(months_employed_py1 == months_after_y1) %>%
#   # at this point we are safe to use their mean hours worked during months employed to filter out people who were really only in side hustles
#   filter(mean_hrs >= 15) %>% 
#   # now we need to filter to those who were only employed in SE 
#   filter(se_months_py1 == months_after_y1)



se_sample <- long_wd %>% 
  left_join(se_quantified, by = "ssuid_spanel_pnum") %>%
  group_by(ssuid_spanel_pnum) %>% 
  mutate(months_employed =sum(ifelse(employment_type != 4,1,0)) ) %>% 
  filter(row_number() > 12) %>%
  ungroup() %>% 
  # Here we want only those who were continuously employed from month 13 onwards.
  filter(months_employed_py1 == months_after_y1) %>%
  # at this point we are safe to use their mean hours worked during months employed to filter out people who were really only in side hustles
  filter(mean_hrs >= 15) %>% 
  # now we need to filter to those who were only employed in SE 
  filter(se_months_py1 == months_after_y1)

```






## March 2025 updates for descriptives comparing WS and SE 
```{r March 2025 update for descriptives comparing WS and SE}
full_time_period_flags <- long_wd %>% 
  arrange(ssuid_spanel_pnum, swave, monthcode) %>% 
  group_by(ssuid_spanel_pnum) %>%
  summarize(ft_se_months = sum(ifelse(mwkhrs >= 15 & employment_type == 2,1,0), na.rm = TRUE),
         pt_se_months = sum(ifelse(mwkhrs < 15 & employment_type == 2,1,0), na.rm = TRUE),
         pt_months = sum(ifelse(mwkhrs < 15,1,0), na.rm = TRUE),
         ft_months = sum(ifelse(mwkhrs >= 15, 1, 0), na.rm = TRUE),
         ft_ws_months = sum(ifelse(mwkhrs >=15 & employment_type == 1,1,0), na.rm = TRUE),
         pt_ws_months = sum(ifelse(mwkhrs < 15 & employment_type == 1,1,0), na.rm = TRUE),
         months = max(row_number()),
         pct_se_ft = ft_se_months/months,
         pct_ws_ft = ft_ws_months/months,
         months_employed = sum(ifelse(employment_type != 4,1,0)),
         mean_hrs = mean(mwkhrs, na.rm = TRUE),
         se_months = sum(ifelse(employment_type == 2, 1,0), na.rm = TRUE),
         ws_months = sum(ifelse(employment_type == 1, 1, 0), na.rm = TRUE)
         ) %>% 
  ungroup() %>% 
  tidylog::filter(months_employed == months) %>% 
  ## now we know these people had at least some employment during each month of our data. So now we filter to those who had an average working hours of >=15 in each month. 
  tidylog::filter(mean_hrs >=15) %>% 
  ## now we need those who were continuously employed in WS or SE
  tidylog::filter(se_months/months == 1 | ws_months/months == 1 ) %>% 
  mutate(employment_group = case_when(se_months/months == 1 ~ "Self-Employed",
                                      ws_months/months == 1 ~ "Wage & Salary"))

## now with the left-join we'll keep only those we've identified above and get some summary stats on them. Could do this all above, but for clarity will keep it separated in case this gets moved to an analysis script later. 
full_time_period_flags %>% 
  left_join(long_wd, by = "ssuid_spanel_pnum") %>% 
  #can group by employment_group here to bring it along since it's constant within individuals based on above restrictions
  group_by(ssuid_spanel_pnum, calyear, employment_group) %>% 
  summarize(tpearn = sum(tpearn, na.rm = TRUE),
            msum = sum(msum, na.rm = TRUE)) %>% 
  # the above gets us to yearly values. now we move to person-level summary stats of yearly values 
  ungroup() %>% 
  gtsummary::tbl_summary(by = employment_group, include = c(tpearn, msum),
             statistic = list( ~ "{mean} [{median}] ({sd})")) %>% 
  gtsummary::add_overall() %>% 
  gtsummary::modify_caption("Earnings Comparison, Full-time Workers (Person-Year level)") %>% 
  gtsummary::as_hux_xlsx(file = paste0("earnings_comparison", Sys.Date(),".xlsx"))



full_time_period_flags %>% 
  left_join(long_wd, by = "ssuid_spanel_pnum") %>% 
  group_by(employment_group) %>% 
  summarize(n_people = n_distinct(ssuid_spanel_pnum),
            .groups = "drop")



  

# feed it a vector to convert to log transform that accounts for negative values 
log_transform <- function(x) {
  min_x <- min(x)*-1
  log(x + min_x + 1)
}


ws_vs_se <- full_time_period_flags %>% 
  left_join(long_wd, by = "ssuid_spanel_pnum") %>% 
  group_by(ssuid_spanel_pnum, calyear) %>% 
  summarize(tpearn = sum(tpearn, na.rm = TRUE),
            msum = sum(msum, na.rm = TRUE),
            employment_group = last(employment_group),
            age = max(tage), 
            educ_fct = last(educ_fct),
            race_eth_fct_cpsd = last(race_eth_fct_cpsd),
            sex_fct = last(sex_fct),
            immig_fct = last(immig_fct),
            parent_std = last(parent_std)) %>% 
  # the above gets us to yearly values. now we move to person-level summary stats of yearly values 
  ungroup() %>% 
  mutate(employment_group_fct = factor(employment_group, levels = c("Wage & Salary", "Self-Employed")),
         ln_tpearn = log_transform(tpearn),
         ln_msum = log_transform(msum))

library(plm)
plm_msum <- plm(ln_msum ~ employment_group_fct  + 
                   calyear , 
                data = ws_vs_se,
                   index = c("ssuid_spanel_pnum", "calyear"), 
                   model = "random")

plm_msum2 <- plm(ln_msum ~ employment_group_fct + 
                   age + 
                   I(age^2) + 
                   educ_fct + 
                   race_eth_fct_cpsd + 
                   sex_fct + 
                   immig_fct + 
                   factor(parent_std) + 
                   calyear, 
                 data = ws_vs_se, 
                 index = c("ssuid_spanel_pnum", "calyear"),
                 model = "random")

plm_tpearn <- plm(ln_tpearn ~ employment_group_fct  + 
                   calyear , 
                data = ws_vs_se,
                   index = c("ssuid_spanel_pnum", "calyear"), 
                   model = "random")

plm_tpearn2 <- plm(ln_tpearn ~ employment_group_fct + 
                   age + 
                   I(age^2) + 
                   educ_fct + 
                   race_eth_fct_cpsd + 
                   sex_fct + 
                   immig_fct + 
                   factor(parent_std) + 
                   calyear, 
                 data = ws_vs_se, 
                 index = c("ssuid_spanel_pnum", "calyear"),
                 model = "random") 

library(modelsummary)

ws_vs_se_table <- modelsummary(list(plm_msum,
                                           plm_msum2, 
                                           plm_tpearn, 
                                           plm_tpearn2), 
                                      coef_rename = TRUE, 
                                      estimate = "{estimate} ({std.error}){stars}",
                                      vcov = "robust",
                                      statistic = NULL,
                                      title = "Table XX Robust SE Employment Type predciting Log Annual Earnings", 
                                      output = "gt")

ws_vs_se_table 

library(openxlsx)
wb <- createWorkbook()
addWorksheet(wb, "Wage vs SE earnings")
writeData(wb, ws_vs_se_table, sheet = "Wage vs SE earnings")
saveWorkbook(wb, paste0("working_paper_outputs_prep",Sys.Date(),".xlsx"), overwrite = TRUE)


```

```{r filtering to those with employment past month 12}
se_sample.5 <- long_wd %>%
  left_join(se_quantified, by = "ssuid_spanel_pnum") %>%
  group_by(ssuid_spanel_pnum) %>%
  # getting rid of first year data as we don't need it for analysis since we already made the flags for their y1 statuses.
  filter(row_number() > 12) %>%
  ungroup() %>%
  # Here we want only those who were continuously employed from month 13 onwards.
  filter(months_employed_py1 == months_after_y1) %>%
  # at this point we are safe to use their mean hours worked during months employed to filter out people who were really only in side hustles. We're safe to use it now because the mean_hrs calc ignores NA months so wouldn't be valid if we still had NA months post 12 but we don't based on the above filter of continuously employed. 
  filter(mean_hrs >= 15) %>% 
  # now we need to filter to those who were only employed in SE 
  filter(se_months_py1/months_after_y1 >=.5)
```

Examining missings in the key variables we care about

```{r}
se_sample %>%
  select(ssuid_spanel_pnum,
      swave,
      spanel,
      monthcode,
      race_eth_fct_cpsd,
      sex_fct,
      immig_fct,
      calyear,
      educ_fct,
      industry_fct,
      parent_std,
      unemp_f12,
      y1_status_v2,
      mode_status,
      max_consec_unemp,
      employment_type,
      tpearn, msum, prftb, val,
      thval_home, tval_ast, tval_home, thval_ast, eawbmort, eawbgas, rhlthmth,
      thcyincpov,thcyincpovt2 ) %>% 
  naniar::gg_miss_var()
```

**Business value is the primary issue above. In an ideal dataset it shouldn't be possible to have business value missing if SE. For now we don't drop them since we're really just concerned with earnings, but need to discuss this.**

```{r cleanup missings}
se_sample <- se_sample %>%
  filter(if_all(
    c(
      ssuid_spanel_pnum,
      swave,
      spanel,
      monthcode,
      race_eth_fct_cpsd,
      sex_fct,
      immig_fct,
      calyear,
      educ_fct,
      industry_fct,
      parent_std,
      unemp_f12,
      y1_status_v2,
      mode_status,
      max_consec_unemp,
      employment_type, 
      #val, 
      msum, 
      tpearn,
      prftb, 
      eawbmort, 
      eawbgas,
      rhlthmth,
      rfoods,
      rfoodr,
      thcyincpov,
      thcyincpovt2
    ),
    ~ !is.na(.)
  )) 



se_sample.5 <- se_sample.5 %>%
  # because we allow for .5 SE here there will be records for jobs that were not SE and will therefore be msising for prtb in that row despite that person having another record with prftb equal to a valid value. So we fill those in before deleting missings here 
  group_by(ssuid_spanel_pnum, calyear) %>% 
  fill(prftb, .direction = "downup") %>% 
  ungroup() %>% 
  filter(if_all(
    c(
      ssuid_spanel_pnum,
      swave,
      spanel,
      monthcode,
      race_eth_fct_cpsd,
      sex_fct,
      immig_fct,
      calyear,
      educ_fct,
      industry_fct,
      parent_std,
      unemp_f12,
      y1_status_v2,
      mode_status,
      max_consec_unemp,
      employment_type, 
      #val, 
      msum, 
      tpearn,
      prftb, 
      eawbmort, 
      eawbgas,
      rhlthmth,
      rfoodr,
      rfoods,
      thcyincpov,
      thcyincpovt2
    ),
    ~ !is.na(.)
  )) 


```

```{r}
se_sample <- se_sample %>% 
  mutate(profposi = ifelse(prftb > 0, 1, 0),
         prof10k = ifelse(prftb >= 10000, 1, 0)
         )

se_sample.5 <- se_sample.5 %>% 
  mutate(profposi = ifelse(prftb > 0, 1, 0),
         prof10k = ifelse(prftb >= 10000, 1, 0)
         )
```

# Final data checks.

Note we may need another decision rule around people for business values and for earnings. For instance, the next few tables highlight some odd folks here.

This table shows someone who reports working twenty hours per week for a year, but reports no msum income, no tpearn income, no prftb profit income, no real business value, and no total personal income (tptotinc) and they don't have a large networth or assets. Then in their second year they report working no hours but still reported having a job.

```{r, message = FALSE }
se_sample %>% 
  select(ssuid_spanel_pnum, swave, monthcode, jobid, mwkhrs, msum, tpearn, 
         prftb, employment_type, enjflag_std, val, tptotinc, tage,thnetworth, thval_ast ) %>%
  filter(ssuid_spanel_pnum %in% c("285049440182018101"))  %>% 
  flextable::flextable()

```

On the other hand, this person is reporting working 40 hours but reporting no income. In neither of these cases are they even jobids that we imputed. This was an issue in the Stata data as well (I went back and checked) but I hadn't caught it there.

```{r, message = FALSE }
se_sample %>% 
  select(ssuid_spanel_pnum, swave,jobid,  monthcode, mwkhrs, msum, tpearn, 
         prftb, employment_type, val, tptotinc, tage,thnetworth, thval_ast ) %>%
  filter(ssuid_spanel_pnum %in% c("292136334552182018102"))  %>% 
  flextable::flextable()

```

How big of an issue are these various problems?

Well we have a total of `r se_sample  %>% distinct(ssuid_spanel_pnum) %>% count()` people in the dataset.

The chunk below calculates the number of poeople who at some point report a month with work hours but report no income of any sort during that month.

```{r, message = FALSE }
se_sample %>% filter(mwkhrs > 0 & tpearn == 0 & msum == 0 & tptotinc == 0 & prftb == 0 ) %>% distinct(ssuid_spanel_pnum) %>% count()
```

Perhaps they're just extraordinarily wealthy? Nope. Even with a modest restriction of networth \< 50000 we still see a lot of people with work hours and no income.

```{r}
se_sample %>% filter(mwkhrs > 0 & tpearn == 0 & msum == 0 & tptotinc == 0 & prftb == 0 & thnetworth < 50000) %>% distinct(ssuid_spanel_pnum) %>% count()

```

What about the related issue of months reported with no working hours but they still met our threshold of being employed each month (according to jobid data) and having mean hours greater than or equal to 15.

```{r, message = FALSE }
se_sample %>% filter(mwkhrs == 0) %>% distinct(ssuid_spanel_pnum) %>% count()
se_sample %>% group_by(ssuid_spanel_pnum) %>% summarize(months_0workhours = sum(mwkhrs == 0), months = n()) %>% arrange(desc(months_0workhours))
```

What about those missing business values?

```{r}
se_sample %>% filter(is.na(val)) %>% distinct(ssuid_spanel_pnum) %>% count() 

```

For good measure we'll create a new dataframe that excludes the oddities above and filters to only those with full years after dropping the suspect years.

```{r}
se_sample_cleanest <- se_sample %>% 
  group_by(ssuid_spanel_pnum) %>%
  filter(all(mwkhrs != 0)) %>% 
  filter(!any(mwkhrs > 0 & tpearn == 0 & msum == 0 & tptotinc == 0 & prftb == 0)) %>% ungroup()


se_sample.5_cleanest <- se_sample.5 %>% 
  group_by(ssuid_spanel_pnum) %>% 
  filter(all(mwkhrs != 0)) %>%
  filter(!any(mwkhrs > 0 & tpearn == 0 & msum == 0 & tptotinc == 0 & prftb == 0)) %>% 
  ungroup()
```

# Saving out data

At this point we have multiple potential working datasets. All of the following restrict to working age population and those who we have at least two years of data on (ie can establish based on year 1 how they enter into SE, and then observe at least one year of earnings). Further, they all are also restricted to those individuals that we observe full years of data on, so if someone was missing month 11 in one wave then they get dropped. Put differently, we have to observe each person for all 12 months of the year every year for them to be included. The specific files are described as follows:

-   se_sample: This file filters to those who were employed for all months post year 1 and who were SE each month after year 1 and who worked an average of at least 15 hours per month.

-   se_sample.5: This file only differs from the se_sample in that we loosen the restriction that all months after year 1 had to be SE and allow for only half of the months post year 1 to be SE months for them to be considered in the sample.

-   The se_sample_cleaned and se_sample.5_cleaned are built from the above two datasets, but handle the odd cases described immediately above by excluding those who reported months with working hours but no income of any sort as well as those who reported months with no work hours (even though they reported having a job that month since they had a jobid).

```{r}
saveRDS(se_sample, "se_sample.rds")
saveRDS(se_sample.5, "se_sample_5.rds")
saveRDS(se_sample_cleanest, "se_sample_cleanest.rds") 
saveRDS(se_sample.5_cleanest, "se_sample_5_cleanest.rds")
```
