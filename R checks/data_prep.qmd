---
title: "data_prep"
format: html
---

This is the second script in the process for recreating the Stata anaylses for the SIPP data. This script reads in the raw SIPP files, extracts relevant work/income variables, reshapes the person-month-job variables to align to the person-month variables.

```{r, message = FALSE, warning = FALSE}
rm(list=ls())
library(tidyverse)
library(bit64)
library(tidylog)
```

```{r load data}
monthly <- readRDS("/Volumes/ExtremeSSD/SIPP Data Files/rds/sipp_monthly_combined.rds")
joblevel_wide <- readRDS("/Volumes/ExtremeSSD/SIPP Data Files/rds/sipp_joblevel_combined_wide.rds") 

```

Bring in the monthly/yearly level variables and the joblevel data and create ids for them. We could just use ssuid and pnum but being extra careful here including the spanel in case the SIPP ever reused an ssuid + pnum combo across panels.

```{r create ids}
monthly <- monthly %>% mutate(
  ssuid = as.character.integer64(ssuid),
  ssuid_spanel_pnum = paste0(
        ssuid,
        as.character(spanel),
        as.character(pnum)
      ))


joblevel_wide <- joblevel_wide %>% mutate(
  ssuid = as.character.integer64(ssuid),
  ssuid_spanel_pnum = paste0(
        ssuid,
        as.character(spanel),
        as.character(pnum)
      )
)
```

Here we impute those instances where someone had all of the earnings and job information we care about but did not have a jobid value for that specific job. Because we conduct later analyses at the month level we don't particularly care if this job is just an uncoded version of ejobid 101 , 102, 103 for instance. Put differently, it's unclear from the data quality flags (ajb_ vars) why these are "not in universe" for jobid, but the records contain all the information we'd want so we can impute some fictional jobids. We lose the ability to track if these are the same jobs they held before/after that month but we aren't concerned with that.

```{r data preview for imputation }
joblevel_wide %>% filter(ssuid == "418209316" & pnum == 102) %>% select(ssuid_spanel_pnum, ssuid, pnum, monthcode, contains("enjflag"), contains("jborse"), contains("jobid"), contains("msum"), contains("prftb"), contains("mwkhrs"), contains("ind")) 
```

```{r imputing jobids}
joblevel_wide <- joblevel_wide %>% 
  select(
      'ssuid',
      'spanel',
      'swave',
      'pnum',
      'monthcode',
      'ssuid_spanel_pnum',
      contains("prftb"),
      contains("msum"),
      contains("mwkhrs"),
      contains("jborse"),
      contains("jobid"),
      contains("ind"),
      contains("tbsj")) %>%
    tidylog::mutate(
      ejb1_jobid = ifelse(
        is.na(ejb1_jobid) & !is.na(tjb1_mwkhrs) & !is.na(ejb1_jborse) &
          (!is.na(tjb1_msum) | !is.na(tjb1_prftb)),
        1,
        ejb1_jobid
      ),
      ejb2_jobid = ifelse(
        is.na(ejb2_jobid) & !is.na(tjb2_mwkhrs) & !is.na(ejb2_jborse) &
          (!is.na(tjb2_msum) |
             !is.na(tjb2_prftb)),
        2,
        ejb2_jobid
      ),
      ejb3_jobid = ifelse(
        is.na(ejb3_jobid) & !is.na(tjb3_mwkhrs) & !is.na(ejb3_jborse) &
          (!is.na(tjb3_msum) |
             !is.na(tjb3_prftb)),
        3,
        ejb3_jobid
      ),
      ejb4_jobid = ifelse(
        is.na(ejb4_jobid) & !is.na(tjb4_mwkhrs) & !is.na(ejb4_jborse) &
          (!is.na(tjb4_msum) |
             !is.na(tjb4_prftb)),
        4,
        ejb4_jobid
      ),
      ejb5_jobid = ifelse(
        is.na(ejb5_jobid) & !is.na(tjb5_mwkhrs) & !is.na(ejb5_jborse) &
          (!is.na(tjb5_msum) |
             !is.na(tjb5_prftb)),
        5,
        ejb5_jobid
      ),
      ejb6_jobid = ifelse(
        is.na(ejb6_jobid) & !is.na(tjb6_mwkhrs) & !is.na(ejb6_jborse) &
          (!is.na(tjb6_msum) |
             !is.na(tjb6_prftb)),
        6,
        ejb6_jobid
      ),
      ejb7_jobid = ifelse(
        is.na(ejb7_jobid) & !is.na(tjb7_mwkhrs) & !is.na(ejb7_jborse) &
          (!is.na(tjb7_msum) |
             !is.na(tjb7_prftb)),
        7,
        ejb7_jobid
      )
    )

```
Next we combine the monthly level dataframe with the wide joblevel file. 
```{r combining to joblevel and monthly into dataframe}
full_data_base <- tidylog::left_join(monthly, joblevel_wide, by = c("ssuid_spanel_pnum", "spanel", "swave", "monthcode"))
```

Then we filter to the working age population based on age at entry into dataset. 
```{r filtering to working age sample by age at entry}
full_data <- full_data_base %>% 
  group_by(ssuid_spanel_pnum) %>% 
  mutate(age_entry = min(tage),
         age_exit = max(tage)) %>% 
  filter(age_entry >= 18 & age_entry <= 64) %>% ungroup()
```


They changed the cooding of the unemployment flag (enjflag) between panels, so correcting for that here.
```{r standardizing enjflag unemployment flag}
# Unemployment flag is 0 = not unemployed and 1 = unemployed for 2014 panel. Then switches to 2 = not unemployed and 1 = unemployed for 2018 onwards. So recoding accordingly here 
full_data <- full_data %>% 
  mutate(enjflag_std = ifelse(spanel == 2014 & enjflag == 1, 1,
                              ifelse(spanel >2014 & enjflag == 1, 1,
                                     ifelse(enjflag == 0 | enjflag == 2, 0, NA)))) 
```

Dropping those who never worked.

```{r removing those who never worked}
full_data <- full_data %>% 
  mutate(workless_month = if_all(starts_with("ejb") & ends_with("jobid"), is.na)) %>% 
  mutate(workless_month = ifelse(workless_month, 1, 0)) %>% 
  group_by(ssuid_spanel_pnum) %>% 
  mutate(months_in_data = n(),
         workless_month_tot = sum(workless_month)) %>%
  ungroup() %>% 
  tidylog::filter(months_in_data > workless_month_tot) 

```

Now we need to mark their main job based on number of hours worked and keep only that row for the month.To do that we first do some renaming to make the reshaping easier. Then we reshape the job variables to long format. This is done once and then saved out as it's fairly computationally intensive. 

```{r marking main job}
full_data <- full_data %>% 
  tidylog::select(-ends_with(".y"), -starts_with("ajb")) %>% 
  rename_with(
    ~ gsub("^(tbsj\\d+)(val)$", "\\1_\\2", .), # adding in underscore to match the name formatting of tjb and ejb variables for easier reshaping
    starts_with("tbsj")
  ) 
```

```{r reshaping joblevel to long, include = FALSE, eval = FALSE}
ptm <- proc.time()

long <- full_data %>% 
  pivot_longer(
    cols = matches("^(tjb|ejb|tbsj)\\d+_"),  
    names_to = c("job", ".value"),     
    names_pattern = "^[a-z]+(\\d+)_(.*)$" 
  ) %>% group_by(ssuid_spanel_pnum, swave, monthcode) %>% 
  relocate(ssuid_spanel_pnum, swave, monthcode, jobid, mwkhrs, msum) %>% 
  slice_max(mwkhrs, with_ties = FALSE) %>% ungroup()
proc.time() - ptm
saveRDS(long, "/Volumes/ExtremeSSD/SIPP Data Files/rds/sipp_long_2014_2023.rds")
```

```{r}
long <- readRDS("/Volumes/ExtremeSSD/SIPP Data Files/rds/sipp_long_2014_2023.rds")
```


Here we create a long_wd working dataset and leave the above dataset as a ground truth for data checks. Next we turn to create flags for the type of employment in each month. 1 = WS, 2 = SE, 3 = Other, and 4 = unemployed. 
```{r create long_wd for leaving original long dataframe as reference}
long_wd <- long %>% 
  mutate(employment_type = case_when(jborse ==1 ~  1,
                                     jborse == 2 ~ 2,
                                     jborse == 3 ~ 3,
                                     is.na(jborse) & enjflag_std == 1 ~ 4,
                                     .default = NA)) %>%  # this creates ~300 NAs, where they have no job data for their main job but they don't get flagged as unemployed spell in the enjflag data. So we'll impute unemployment here for these months. 
  tidylog::mutate(employment_type = ifelse(is.na(employment_type), 4, employment_type)) %>% 
  tidylog::mutate(hispanic = case_when(eorigin == 1 ~ 1,
                                      eorigin == 2 ~ 0,
                                      .default= NA)) 


```

In the Stata analysis I noticed some issues with the sipp data having inconsistent race/ethnicity variables. Here again, as in the Stata version, we correct for this and impute the first race/eth reported forwards. 

For example, 378 people changed their response to whether or not they were hispanic during the course of their survey participation. Likewise, 1747 people changed their response to their race question during the course of the survey.

```{r investigate inconsistent race and ethnicity}
temp <- long_wd %>% group_by(ssuid_spanel_pnum) %>% 
  mutate(erace_change = erace != first(erace, default= first(erace)),
         hispanic_change = hispanic !=first(hispanic, default = first(hispanic))) %>% 
  ungroup() %>% relocate(ssuid_spanel_pnum,  erace_change, erace, hispanic, hispanic_change) 

temp %>% group_by(hispanic_change) %>% distinct(ssuid_spanel_pnum) %>% count()
temp %>% group_by(erace_change) %>% distinct(ssuid_spanel_pnum) %>% count()
```

Now we restart the recoding of demographic variables to analysis ready versions with labels etc. 

```{r recoding demographic variables}
long_wd <- long_wd %>% 
  arrange(ssuid_spanel_pnum, swave, monthcode) %>% 
  group_by(ssuid_spanel_pnum) %>% 
  # given above inconsistent reporting of race and ethnicity here we categorize each person based on their first value reported
  mutate(erace_std = first(erace),
         hispanic_std = first(hispanic)) %>% 
  ungroup() %>% 
  # create combined version of race/ethnicity
  mutate(race_eth = case_when(hispanic_std == 1 ~ "Hispanic",
                              erace_std == 1 ~ "White", 
                              erace_std == 2 ~ "Black", 
                              erace_std == 3 ~ "Asian",
                              erace_std == 4 ~ "Other",
                              .default = NA),
         race_eth_fct = factor(race_eth, levels = c("White", "Black", "Hispanic", "Asian", "Other")),
         race_eth_fct_cpsd = fct_collapse(race_eth_fct, White = c("White"), Non_white = c("Black", "Asian", "Hispanic", "Other")),
         sex_fct = factor(esex, levels = c(1,2), labels = c("Male", "Female")),
         immig_fct = factor(ebornus, levels = c(1,2), labels = c("US Born", "Immigrant")),
        # https://www2.census.gov/programs-surveys/sipp/2023/2023_SIPP_Data_Overview_Handout_SEP23.pdf
         calyear = case_when(spanel == 2014 & swave == 1 ~ 2013, 
                             spanel == 2014 & swave == 2 ~ 2014,
                             spanel == 2014 & swave == 3 ~ 2015, 
                             spanel == 2014 & swave == 4 ~ 2016, 
                             
                             spanel == 2018 & swave == 1 ~ 2017,
                             spanel == 2018 & swave == 2 ~ 2018,
                             spanel == 2018 & swave == 3 ~ 2019, 
                             spanel == 2018 & swave == 4 ~ 2020, 
                             
                             spanel == 2019 & swave == 1 ~ 2018,
                             
                             spanel == 2020 & swave == 1 ~ 2019,
                             spanel == 2020 & swave == 2 ~ 2020,
                             spanel == 2020 & swave == 3 ~ 2021, 
                             spanel == 2020 & swave == 4 ~ 2022,
                             
                             spanel == 2021 & swave == 1 ~ 2020,
                             spanel == 2021 & swave == 2 ~ 2021,
                             spanel == 2021 & swave == 3 ~ 2022,
                             
                             spanel == 2022 & swave == 1 ~ 2021,
                             spanel == 2022 & swave == 2 ~ 2022,
                             
                             spanel == 2023 & swave == 1 ~ 2022,
                             .default = NA),
         educ_fct = factor(case_when(eeduc >= 43 ~ "4-year Degree or More",
                              eeduc >= 40 ~ "Some College or Assoc",
                              eeduc < 40 ~ "HS or Less", 
                              .default = NA), levels = c("HS or Less", "Some College or Assoc", "4-year Degree or More")),
         industry_fct = case_when(ind < 570 ~ "Forestry, Farming, Fishing, Hunting, & Mining",
                                  ind == 770 ~ "Construction",
                                  ind >=1070 & ind <=3990 ~ "Manufacturing",
                                  ind >= 4070 & ind <= 4590 ~ "Wholesale Trade",
                                  ind >= 4670 & ind <= 5790 ~ "Retail Trade",
                                  (ind >=6070 & ind <= 6390) | (ind >= 570 & ind <= 690) ~ "Transportation, Warehousing & Utilities",
                                  ind >= 6470 & ind <= 6780 ~ "Information",
                                  ind >= 6870 & ind <= 7190 ~ "Finance and Insurance, and Real Estate, and Rental and Leasing",
                                  ind >= 7270 & ind <= 7790 ~ "Professional, Scientific, and Management, and Administrative, and Waste Management Services",
                                  ind >= 7860 & ind <= 8470  ~ "Educational Services, and Health Care and Social Assistance",
                                  ind >= 8560 & ind <= 8690 ~ "Arts, Entertainment, and Recreation, and Accommodation and Food Services",
                                  ind >= 8770 & ind <= 9290 ~ "Other Services, Except Public Administration",
                                  ind >= 9370 & ind <= 9590  ~ "Public Administration",
                                  ind >= 9890  ~ "Military",
                                  .default = NA), 
         parent = ifelse(epar_scrnr == 1, 1, 
                         ifelse(epar_scrnr == 2, 0, NA))
         
         
  )
```
Similar to the race/ethnicity inconsistent coding, the parent variable has instances where someone flips from being a parent to not being a parent (at a scale that seems unlikely in the US mortality context). Obviously someone could go from not being a parent to being a parent, but we have people go from being a parent to not being a parent, using either of the parent variables we have (tceb or epar_scrnr). Really we're most interested in if they have a dependent child but we use this measure and impute forwards if someone ever reported having a child.

```{r}
temp <- long_wd %>% 
  arrange(ssuid_spanel_pnum, swave, monthcode) %>%  
  group_by(ssuid_spanel_pnum) %>% 
  mutate(parent_disappear = parent < first(parent)) %>% ungroup()

monthly %>% filter(ssuid_spanel_pnum == "114285465212021103") %>% select(swave, monthcode, tceb, epar_scrnr) # example of someone with inconsistent parent information within the base data. 

temp %>% group_by(parent_disappear) %>% distinct(ssuid_spanel_pnum) %>% count()
temp %>% filter(ssuid_spanel_pnum == "114285465212021103") %>% select(swave, monthcode, tceb, epar_scrnr, parent)
```

Continuing work from the last chunk with examining what is going on with the parent variables in the data. 

```{r}
temp <- long_wd %>% 
  arrange(ssuid_spanel_pnum, swave, monthcode) %>% 
  group_by(ssuid_spanel_pnum) %>% 
  mutate(parent_first = first(parent),
         parent_last = last(parent)) %>% 
  # as we saw above some people reported moving from being a parent to being a non-parent, so we can carry that forwards. This is similar to the tceb issue where people reported having biological children in an earlier wave and then report not occurring. Using the epar_scrnr this is 934 people with this disappearing child (could be due to deaths I suppose, but the question seems more general to did they ever have a kid. )
  mutate(parent_std= parent,
         parent_std = cummax(parent_std)) %>% ungroup()

temp %>% filter(ssuid_spanel_pnum == "114285465212021103") %>% select(swave, monthcode, tceb, epar_scrnr, contains("parent")) %>% print(n = 100)
temp %>% filter(ssuid_spanel_pnum == "2920924180182014101") %>% select(swave, monthcode, tceb, epar_scrnr, contains("parent")) %>% print(n = 100)

```

```{r imputing parental status}
long_wd <- long_wd %>% 
  arrange(ssuid_spanel_pnum, swave, monthcode) %>% 
  group_by(ssuid_spanel_pnum) %>% 
  mutate(parent_first = first(parent),
         parent_last = last(parent)) %>% 
  # as we saw above some people reported moving from being a parent to being a non-parent, so we can carry that forwards. This is similar to the tceb issue where people reported having biological children in an earlier wave and then report not occurring. Using the epar_scrnr this is 934 people with this disappearing child (could be due to deaths I suppose, but the question seems more general to did they ever have a kid. )
  mutate(parent_std= parent,
         parent_std = cummax(parent_std)) %>% ungroup() 
```

## Filtering to those with full years of data.

Representative examples to check, so this person 7178160572292014102 has 17 months in the data, and this person has three 8818607717842014104. We want to lose them both and end up with only those who we observe for a full 12 months in each wave.

```{r filtering to only those with full years of data}
full_year_markers <- long_wd %>% 
  group_by(ssuid_spanel_pnum, swave) %>% 
  # check that in each wave the person has a full 12 months. 
  summarize(has_full_year = all(1:12 %in% monthcode)) %>%
  ungroup() %>% 
  # filter to only those waves where a person had 12 months of data. 
  filter(has_full_year) 

full_year_markers %>% filter(ssuid_spanel_pnum %in% c("7178160572292014102", "8818607717842014104"))

# merge this in with only keeping the records that had full years of data. 
long_wd <- long_wd %>% inner_join(full_year_markers, by = c("ssuid_spanel_pnum", "swave")) %>% 
  # make a new months_in_data column now that we've removed partial waves
  select(-months_in_data) %>% 
  group_by(ssuid_spanel_pnum) %>% 
  mutate(months_in_data = n())

table(long_wd$months_in_data) # confirming we have full years for everyone at this point. 
```

Next we need to establish their frist year statuses so that we can group people according to how they're entering into SE. 
```{r function to find max mode}
# this function calculates the mode of a set of values and breaks ties by selecting the larger mode. So in our use case we're defaulting towards unemployment if someone had 4 months of SE, 4 months of WS and 4 months of Unemployment we would categorize them as unemployed in that first year based on this funciton. 
find_max_mode <- function(x) {
  u <- unique(x)
  tab <- tabulate(match(x, u))
  max(u[tab == max(tab)]) 
}
```

```{r capturing first year status}
mode_statuses <- long_wd %>% select(ssuid_spanel_pnum, swave, monthcode, employment_type) %>% 
  arrange(ssuid_spanel_pnum, swave, monthcode) %>% 
  group_by(ssuid_spanel_pnum) %>% 
  filter(row_number() <=12) %>% 
  summarize(mode_status = find_max_mode(employment_type)) 

long_wd <- long_wd %>% 
  left_join(mode_statuses, by = "ssuid_spanel_pnum") # this adds their mode status during the first year to all records for the individual. 
```

We're also interested in the consecutive months of unemployment, not just when unemployment is most common status. 


```{r creating max_consec uneployment measure}
library(data.table)
consec_unemp <- setDT(long_wd)
consec_unemp <- consec_unemp %>% 
  group_by(ssuid_spanel_pnum) %>% 
  filter(row_number() <=12) %>% 
  mutate(
    ### Gen value of 1 for first run, 2 for second stretch but doesn't filter to only those that are unemployed months
    stretch = rleid(workless_month),
    stretch_workless = ifelse(workless_month == 1, stretch, NA ),
    is_non_missing = !is.na(stretch_workless), # could recode this with just referencing stretch_workless
    spell_id = cumsum(is_non_missing & lag(!is_non_missing, default = TRUE)), # Identify spell groups
    spell_length = ifelse(is_non_missing, ave(is_non_missing, ssuid_spanel_pnum, spell_id, FUN = cumsum), 0),
    max_consec_unemp = max(spell_length, na.rm=TRUE)) %>%
  ungroup()


# checking it captured people correctly. 
consec_unemp %>% select(ssuid_spanel_pnum, swave, monthcode, employment_type, 
                workless_month, stretch, stretch_workless, is_non_missing,
                spell_id, spell_length, max_consec_unemp) %>% filter(ssuid_spanel_pnum %in% c("1288929322014101", "1142851342014103", "292418136626182018102")) %>% select(ssuid_spanel_pnum, monthcode, employment_type, workless_month, max_consec_unemp) %>% print(n = 100)

consec_unemp <- consec_unemp %>% 
  group_by(ssuid_spanel_pnum) %>% 
  summarize(max_consec_unemp = first(max_consec_unemp, na.rm = TRUE))
```

```{r merging in unemployment streak measure  }
long_wd <- long_wd %>% 
  left_join(consec_unemp, by = "ssuid_spanel_pnum")
```


We decided to exclud those in the military and those who were ever employed as "other" employment type. So I drop those here. 
```{r filtering out those who started out as other employment as modal status}
long_wd <- long_wd %>% 
  group_by(ssuid_spanel_pnum) %>% 
  tidylog::filter(!any(mode_status == 3)) %>% 
  tidylog::filter(!any(industry_fct == "Military", na.rm = TRUE)) %>% 
  ungroup()

```

Next we create our more generous measure of unemployment where even if unemployment wasn't the modal status during the first year, if they experienced a period of 3 months of unemployment we mark them as unemployed during their first year. 

```{r replicating y1_status_v2 from stata script}
# Take our modal status, but override the mode if someone experienced 3 or more months of unemployment during first year in the data. 
y1_statuses <- long_wd %>% 
  select(ssuid_spanel_pnum, swave, monthcode, employment_type, workless_month, mode_status) %>% 
  arrange(ssuid_spanel_pnum, swave, monthcode) %>% 
  group_by(ssuid_spanel_pnum) %>% 
  filter(row_number() <=12) %>%  # keep each person's first year only. 
  summarize(unemp_f12 = sum(workless_month, na.rm = TRUE),
            mode_status = first(mode_status)) %>%
  ungroup() %>% 
  mutate(y1_status_v2 = ifelse(unemp_f12 >=3, 4,
                                  mode_status)) 

```

Joining the new measure of y1 status to the main working dataframe. 
```{r}
long_wd <- long_wd %>% 
  left_join(y1_statuses %>% select(ssuid_spanel_pnum, y1_status_v2, unemp_f12), by = "ssuid_spanel_pnum")
```


Dropping those we only have one year of data for as we won't be able to set their baseline entry status and then observe any earnings. 
```{r dropping those we only have one year of data on}
table(long_wd$months_in_data, useNA = "ifany")
long_wd <- long_wd %>% 
  filter(months_in_data > 12 ) ## really only == 12 here since we've already filterd to only thsoe with full years. We can do this without grouping because we have 
```
Here I create measures of the number of months people held each employment status and number of hours. 
```{r}
se_quantified <- long_wd %>% 
  arrange(ssuid_spanel_pnum, swave, monthcode) %>% 
  group_by(ssuid_spanel_pnum) %>%
   # get only records after first year
  filter(row_number() > 12) %>% 
  summarize(ft_se_months_py1 = sum(ifelse(mwkhrs >= 15 & employment_type == 2,1,0), na.rm = TRUE),
         pt_se_months_py1 = sum(ifelse(mwkhrs < 15 & employment_type == 2,1,0), na.rm = TRUE),
         pt_months_py1 = sum(ifelse(mwkhrs < 15,1,0), na.rm = TRUE),
         ft_months_py1 = sum(ifelse(mwkhrs >= 15, 1, 0), na.rm = TRUE),
         ft_ws_months_py1 = sum(ifelse(mwkhrs >=15 & employment_type == 1,1,0), na.rm = TRUE),
         pt_ws_months_py1 = sum(ifelse(mwkhrs < 15 & employment_type == 1,1,0), na.rm = TRUE),
         months_after_y1 = max(row_number()),
         pct_se_py1_ft = ft_se_months_py1/months_after_y1,
         months_employed_py1 = sum(ifelse(employment_type != 4,1,0)),
         mean_hrs = mean(mwkhrs, na.rm = TRUE),
         se_months_py1 = sum(ifelse(employment_type == 2, 1,0), na.rm = TRUE),
         ws_months_py1 = sum(ifelse(employment_type == 1, 1, 0), na.rm = TRUE)
         ) %>% 
  ungroup()



```

```{r}
almost_ft <- se_quantified %>%
  filter(months_after_y1 != ft_months_py1) %>%
  select(ssuid_spanel_pnum) %>% as.vector()


## confirming here that these people are actually correctly coded
joblevel_wide %>% filter(ssuid_spanel_pnum %in% almost_ft$ssuid_spanel_pnum) %>%
  select(
    ssuid_spanel_pnum,
    swave,
    monthcode,
    contains("msum"),
    contains("mwkhrs"),-contains("alt"),
    contains("jborse")
  ) %>%
  View()




temp_ft_equals_months <- long_wd %>%
  left_join(se_quantified, by = "ssuid_spanel_pnum") %>%
  group_by(ssuid_spanel_pnum) %>%
  filter(row_number() > 12) %>%
  ungroup() %>%
  # based on the number of people we lose here I think we actually want to allow some flexibility here.
  tidylog::filter(months_after_y1 == ft_months_py1)


temp_ft_equals_months %>% select(
  ssuid_spanel_pnum,
  swave,
  monthcode,
  months_in_data,
  months_after_y1,
  ft_months_py1,
  months_employed_py1,
  workless_month,
  enjflag_std,
  jobid,
  msum,
  mwkhrs
) %>% View()
```

Slight discrepancy here for enjflag vs workless_month definition.

![](images/clipboard-1155767985.png)

What do we do about the people like ssuid_spanel_pnum == "292092406784182018101" who are in our data for 48 months, and we use their first year to establish their status, then during the following 36 months, we previously would've lost them due to their work-hours not always being \>= 15. But for this person, that decrease in work hours is only for one month. In other words, for 35 out of 36 months we're looking at their earnings they have a full-time job but only one where they work fewer than 15 hours.

**Filter to only those with months_employed_py1 == months_after_y1, then filter to those with se as \>.5 percent of the months after that and then to account for side-hustles filter to their mean working hours as \>15.**

```{r}
se_quantified %>% filter(ssuid_spanel_pnum == "292092406784182018101") %>% flextable::flextable()
long_wd %>% filter(ssuid_spanel_pnum == "1142851342014101") %>% flextable::flextable() # this person should get filtered out as they have unemployed months after year 1

long_wd %>% filter(ssuid_spanel_pnum == "292092406784182018101") %>% flextable::flextable()
```



```{r}

temp_ft_equals_months <- long_wd %>%
  left_join(se_quantified, by = "ssuid_spanel_pnum") %>%
  group_by(ssuid_spanel_pnum) %>%
  filter(row_number() > 12) %>%
  ungroup() %>%
  # based on the number of people we lose here I think we actually want to allow some flexibility here.
  tidylog::filter(months_after_y1 != ft_months_py1)

```

```{r}
pt_months_hrs <- long_wd %>%
  mutate(pt_month = ifelse(mwkhrs < 15, 1, 0)) %>%
  group_by(ssuid_spanel_pnum, pt_month) %>%
  summarize(
    mean_hours = mean(mwkhrs, na.rm = TRUE),
    tot_pt_months = sum(pt_month, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  filter(pt_month == 1)
```

```{r filtering to our SE sample}
# here we filter to those with employment at least every month post month 12. But we relax the restriction on the need to be full-time employed 

se_sample <- long_wd %>%
  left_join(se_quantified, by = "ssuid_spanel_pnum") %>%
  group_by(ssuid_spanel_pnum) %>%
  # getting rid of first year data as we don't need it for analysis since we already made the flags for their y1 statuses.
  filter(row_number() > 12) %>%
  ungroup() %>%
  # Here we want only those who were continuously employed from month 13 onwards.
  filter(months_employed_py1 == months_after_y1) %>%
  # at this point we are safe to use their mean hours worked during months employed to filter out people who were really only in side hustles
  filter(mean_hrs >= 15) %>% 
  # now we need to filter to those who were only employed in SE 
  filter(se_months_py1 == months_after_y1)
```


```{r filtering to those with employment past month 12}
se_sample.5 <- long_wd %>%
  left_join(se_quantified, by = "ssuid_spanel_pnum") %>%
  group_by(ssuid_spanel_pnum) %>%
  # getting rid of first year data as we don't need it for analysis since we already made the flags for their y1 statuses.
  filter(row_number() > 12) %>%
  ungroup() %>%
  # Here we want only those who were continuously employed from month 13 onwards.
  filter(months_employed_py1 == months_after_y1) %>%
  # at this point we are safe to use their mean hours worked during months employed to filter out people who were really only in side hustles. We're safe to use it now because the mean_hrs calc ignores NA months so wouldn't be valid if we still had NA months post 12 but we don't based on the above filter of continuously employed. 
  filter(mean_hrs >= 15) %>% 
  # now we need to filter to those who were only employed in SE 
  filter(se_months_py1/months_after_y1 >=.5)
```
Examining missings in the key variables we care about
```{r}
se_sample %>%
  select(ssuid_spanel_pnum,
      swave,
      spanel,
      monthcode,
      race_eth_fct_cpsd,
      sex_fct,
      immig_fct,
      calyear,
      educ_fct,
      industry_fct,
      parent_std,
      unemp_f12,
      y1_status_v2,
      mode_status,
      max_consec_unemp,
      employment_type,
      tpearn, msum, prftb, 
      thval_home, tval_ast, tval_home, thval_ast) %>% 
  naniar::gg_miss_var()
```


We see above there are no missings, which is expected at this point, but just running the code for good measure. 
```{r cleanup missings}
se_sample <- se_sample %>%
  filter(if_all(
    c(
      ssuid_spanel_pnum,
      swave,
      spanel,
      monthcode,
      race_eth_fct_cpsd,
      sex_fct,
      immig_fct,
      calyear,
      educ_fct,
      industry_fct,
      parent_std,
      unemp_f12,
      y1_status_v2,
      mode_status,
      max_consec_unemp,
      employment_type
    ),
    ~ !is.na(.)
  )) %>%
  filter(!is.na(msum) & workless_month != 1) %>% 
  filter(!is.na(tpearn) & workless_month != 1) 

```



```{r function to log transform vars with negative values in them}
# feed it a vector to convert to log transform that accounts for negative values 
log_transform <- function(x) {
  min_x <- min(x)*-1
  log(x + min_x + 1)
}
```


```{r}
se_sample <- se_sample %>% 
  mutate(profposi = ifelse(prftb > 0, 1, 0),
         prof10k = ifelse(prftb >= 10000, 1, 0),
         ln_tpearn = log_transform(tpearn),
         ln_msum = log(msum),
         )
  
```






Note we may need another decision rule around people for business values and for earnings. For instance, the next few tables highlight some odd folks here. 

This table shows someone who reports working twenty hours per week for a year, but repots no msum income, no tpearn income, no prftb profit income, no real business value, and no total personal income (tptotinc) and they don't have a large networth or assets. Then in their second year they report working no hours but still reported having a job. 
```{r, message = FALSE }
se_sample %>% 
  select(ssuid_spanel_pnum, swave, monthcode, jobid, mwkhrs, msum, tpearn, 
         prftb, employment_type, enjflag_std, val, tptotinc, tage,thnetworth, thval_ast ) %>%
  filter(ssuid_spanel_pnum %in% c("285049440182018101"))  %>% 
  flextable::flextable()

```


Relatedly, this person is reporting 
```{r, message = FALSE }
se_sample %>% 
  select(ssuid_spanel_pnum, swave, monthcode, mwkhrs, msum, tpearn, 
         prftb, employment_type, val, tptotinc, tage,thnetworth, thval_ast ) %>%
  filter(ssuid_spanel_pnum %in% c("292136334552182018102"))  %>% 
  flextable::flextable()

```


How big of an issue are these folks
```{r, message = FALSE }
se_sample %>% filter(is.na(val)) %>% distinct(ssuid_spanel_pnum) %>% count() 
se_sample %>% filter(mwkhrs > 0 & tpearn == 0 & msum == 0 & tptotinc == 0) %>% distinct(ssuid_spanel_pnum) %>% count()
se_sample %>% filter(mwkhrs == 0) %>% distinct(ssuid_spanel_pnum) %>% count()
```

// recoding profits 
gen profposi=tjb_prftb>0 if tjb_prftb<. // 
tab profpos, missing
gen prof10k=tjb_prftb>=10000 if tjb_prftb<.
tab prof10k, missing

foreach x in  tjb_prftb tbsjval {
	egen min_`x' = min(`x')
	replace min_`x' = min_`x' *-1
	gen ln_`x' = ln(`x' + min_`x'+1)
} 




```{r}
average_earnings <- se_sample %>%
  group_by(ssuid_spanel_pnum) %>%
  summarize(
    people = n_distinct(ssuid_spanel_pnum),
    # the following three are all constant within individuals so we just grab their first value
    y1_status_v2 = first(y1_status_v2),
    race_eth_fct_cpsd = first(race_eth_fct_cpsd),
    sex_fct = first(sex_fct),
    # here we take their highest education value ever observed 
    educ_fct = max(educ_fct),
    avg_earnings = mean(tpearn),
    avg_msum_earnings = mean(msum)
  ) %>%
  ungroup()

```

```{r}
table(average_earnings$educ_fct)
table(average_earnings$educ_fct, average_earnings$y1_status_v2)
table(average_earnings$race_eth_fct_cpsd, average_earnings$y1_status_v2)
```

To-dos: - look at annual earnings - test descriptives with weights included - look at regressions, - test regressions with weights included
