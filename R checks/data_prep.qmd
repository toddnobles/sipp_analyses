---
title: "data_prep"
format: html
---

This is the second script in the process for recreating the Stata anaylses for the SIPP data. This script reads in the raw SIPP files, extracts relevant work/income variables, reshapes the person-month-job variables to align to the person-month variables.

```{r}
rm(list=ls())
library(tidyverse)
library(bit64)
```

```{r load data}
monthly <- readRDS("/Volumes/ExtremeSSD/SIPP Data Files/rds/sipp_monthly_combined.rds")
joblevel_wide <- readRDS("/Volumes/ExtremeSSD/SIPP Data Files/rds/sipp_joblevel_combined_wide.rds") 

```

Bring in the monthly/yearly level variables and the joblevel data and create ids for them. We could just use ssuid and pnum but being extra careful here including the spanel in case the SIPP ever reused an ssuid + pnum combo across panels.

```{r create ids}
monthly <- monthly %>% mutate(
  ssuid = as.character.integer64(ssuid),
  ssuid_spanel_pnum = paste0(
        ssuid,
        as.character(spanel),
        as.character(pnum)
      ))


joblevel_wide <- joblevel_wide %>% mutate(
  ssuid = as.character.integer64(ssuid),
  ssuid_spanel_pnum = paste0(
        ssuid,
        as.character(spanel),
        as.character(pnum)
      )
)
```

Here we impute those instances where someone had all of the earnings and job information we care about but did not have a jobid value for that specific job. Because we conduct later analyses at the month level we don't particularly care if this job is just an uncoded version of ejobid 101 , 102, 103 for instance. Put differently, it's unclear from the data quality flags why these are "not in universe" for jobid, but the records contain all the information we'd want so we can impute some fictional jobids. We lose the ability to track if these are the same jobs they held before/after that month but we aren't concerned with that.

```{r data preview for imputation }
joblevel_wide %>% filter(ssuid == "418209316" & pnum == 102) %>% select(ssuid_spanel_pnum, ssuid, pnum, monthcode, contains("enjflag"), contains("jborse"), contains("jobid"), contains("msum"), contains("prftb"), contains("mwkhrs"), contains("ind")) 
```

```{r imputing jobids}
joblevel_wide <- joblevel_wide %>% 
  select(
      'ssuid',
      'spanel',
      'swave',
      'pnum',
      'monthcode',
      'ssuid_spanel_pnum',
      contains("prftb"),
      contains("msum"),
      contains("mwkhrs"),
      contains("jborse"),
      contains("jobid"),
      contains("ind"),
      contains("tbsj")) %>%
    tidylog::mutate(
      ejb1_jobid = ifelse(
        is.na(ejb1_jobid) & !is.na(tjb1_mwkhrs) & !is.na(ejb1_jborse) &
          (!is.na(tjb1_msum) | !is.na(tjb1_prftb)),
        1,
        ejb1_jobid
      ),
      ejb2_jobid = ifelse(
        is.na(ejb2_jobid) & !is.na(tjb2_mwkhrs) & !is.na(ejb2_jborse) &
          (!is.na(tjb2_msum) |
             !is.na(tjb2_prftb)),
        2,
        ejb2_jobid
      ),
      ejb3_jobid = ifelse(
        is.na(ejb3_jobid) & !is.na(tjb3_mwkhrs) & !is.na(ejb3_jborse) &
          (!is.na(tjb3_msum) |
             !is.na(tjb3_prftb)),
        3,
        ejb3_jobid
      ),
      ejb4_jobid = ifelse(
        is.na(ejb4_jobid) & !is.na(tjb4_mwkhrs) & !is.na(ejb4_jborse) &
          (!is.na(tjb4_msum) |
             !is.na(tjb4_prftb)),
        4,
        ejb4_jobid
      ),
      ejb5_jobid = ifelse(
        is.na(ejb5_jobid) & !is.na(tjb5_mwkhrs) & !is.na(ejb5_jborse) &
          (!is.na(tjb5_msum) |
             !is.na(tjb5_prftb)),
        5,
        ejb5_jobid
      ),
      ejb6_jobid = ifelse(
        is.na(ejb6_jobid) & !is.na(tjb6_mwkhrs) & !is.na(ejb6_jborse) &
          (!is.na(tjb6_msum) |
             !is.na(tjb6_prftb)),
        6,
        ejb6_jobid
      ),
      ejb7_jobid = ifelse(
        is.na(ejb7_jobid) & !is.na(tjb7_mwkhrs) & !is.na(ejb7_jborse) &
          (!is.na(tjb7_msum) |
             !is.na(tjb7_prftb)),
        7,
        ejb7_jobid
      )
    )

```

```{r combining to joblevel and monthly into dataframe}
full_data_base <- tidylog::left_join(monthly, joblevel_wide, by = c("ssuid_spanel_pnum", "spanel", "swave", "monthcode"))
```

```{r filtering to working age sample by age at entry}
full_data <- full_data_base %>% 
  group_by(ssuid_spanel_pnum) %>% 
  mutate(age_entry = min(tage),
         age_exit = max(tage)) %>% 
  filter(age_entry >= 18 & age_entry <= 64) %>% ungroup()
```

```{r standardizing enjflag unemployment flag}
# Unemployment flag is 0 = not unemployed and 1 = unemployed for 2014 panel. Then switches to 2 = not unemployed and 1 = unemployed for 2018 onwards. So recoding accordingly here 
full_data <- full_data %>% 
  mutate(enjflag_std = ifelse(spanel == 2014 & enjflag == 1, 1,
                              ifelse(spanel >2014 & enjflag == 1, 1,
                                     ifelse(enjflag == 0 | enjflag == 2, 0, NA)))) 
```

Dropping those who never worked

```{r removing those who never worked}
full_data <- full_data %>% 
  mutate(workless_month = if_all(starts_with("ejb") & ends_with("jobid"), is.na)) %>% 
  mutate(workless_month = ifelse(workless_month, 1, 0)) %>% 
  group_by(ssuid_spanel_pnum) %>% 
  mutate(months_in_data = n(),
         workless_month_tot = sum(workless_month)) %>%
  ungroup() %>% 
  tidylog::filter(months_in_data > workless_month_tot) 

```

Now we need to mark their main job based on number of hours worked and keep only that row for the month.

```{r marking main job}
full_data <- full_data %>% 
  tidylog::select(-ends_with(".y"), -starts_with("ajb")) %>% 
  rename_with(
    ~ gsub("^(tbsj\\d+)(val)$", "\\1_\\2", .), # adding in underscore to match the name formatting of tjb and ejb variables for easier reshaping
    starts_with("tbsj")
  ) 
```

```{r reshaping joblevel to long, include = FALSE, eval = FALSE}
ptm <- proc.time()

long <- full_data %>% 
  #head(1000000) %>% 
  pivot_longer(
    cols = matches("^(tjb|ejb|tbsj)\\d+_"),  
    names_to = c("job", ".value"),     
    names_pattern = "^[a-z]+(\\d+)_(.*)$" 
  ) %>% group_by(ssuid_spanel_pnum, swave, monthcode) %>% 
  relocate(ssuid_spanel_pnum, swave, monthcode, jobid, mwkhrs, msum) %>% 
  slice_max(mwkhrs, with_ties = FALSE) %>% ungroup()
proc.time() - ptm
saveRDS(long, "/Volumes/ExtremeSSD/SIPP Data Files/rds/sipp_long_2014_2023.rds")
```

```{r}
long <- readRDS("/Volumes/ExtremeSSD/SIPP Data Files/rds/sipp_long_2014_2023.rds")
```

```{r cleaning up memory}
rm(full_data, full_data_base, long2)
```

```{r create long_wd for leaving original long dataframe as reference}
long_wd <- long %>% 
  mutate(employment_type = case_when(jborse ==1 ~  1,
                                     jborse == 2 ~ 2,
                                     jborse == 3 ~ 3,
                                     is.na(jborse) & enjflag_std == 1 ~ 4,
                                     .default = NA)) %>%  # this creates ~300 NAs, where they have no job data for their main job but they don't get flagged as unemployed spell in the enjflag data. So we'll impute unemployment here for these months. 
  tidylog::mutate(employment_type = ifelse(is.na(employment_type), 4, employment_type)) %>% 
  tidylog::mutate(hispanic = case_when(eorigin == 1 ~ 1,
                                      eorigin == 2 ~ 0,
                                      .default= NA)) 


```

Investigating inconsistent race and ethnicity values for individuals. For example, 378 people changed their response to whether or not they were hispanic during the course of their survey participation. Likewise, 1747 people changed their response to their race question during the course of the survey.

```{r investigate inconsistent race and ethnicity}
temp <- long_wd %>% group_by(ssuid_spanel_pnum) %>% 
  mutate(erace_change = erace != first(erace, default= first(erace)),
         hispanic_change = hispanic !=first(hispanic, default = first(hispanic))) %>% 
  ungroup() %>% relocate(ssuid_spanel_pnum,  erace_change, erace, hispanic, hispanic_change) 

temp %>% group_by(hispanic_change) %>% distinct(ssuid_spanel_pnum) %>% count()
temp %>% group_by(erace_change) %>% distinct(ssuid_spanel_pnum) %>% count()
```

# recoding demographic variables

```{r recoding demographic variables}
long_wd <- long_wd %>% 
  arrange(ssuid_spanel_pnum, swave, monthcode) %>% 
  group_by(ssuid_spanel_pnum) %>% 
  # given above inconsistent reporting of race and ethnicity here we categorize each person based on their first value reported
  mutate(erace_std = first(erace),
         hispanic_std = first(hispanic)) %>% 
  ungroup() %>% 
  # create combined version of race/ethnicity
  mutate(race_eth = case_when(hispanic_std == 1 ~ "Hispanic",
                              erace_std == 1 ~ "White", 
                              erace_std == 2 ~ "Black", 
                              erace_std == 3 ~ "Asian",
                              erace_std == 4 ~ "Other",
                              .default = NA),
         race_eth_fct = factor(race_eth, levels = c("White", "Black", "Hispanic", "Asian", "Other")),
         race_eth_fct_cpsd = fct_collapse(race_eth_fct, White = c("White"), Non_white = c("Black", "Asian", "Hispanic", "Other")),
         sex_fct = factor(esex, levels = c(1,2), labels = c("Male", "Female")),
         immig_fct = factor(ebornus, levels = c(1,2), labels = c("US Born", "Immigrant")),
        # https://www2.census.gov/programs-surveys/sipp/2023/2023_SIPP_Data_Overview_Handout_SEP23.pdf
         calyear = case_when(spanel == 2014 & swave == 1 ~ 2013, 
                             spanel == 2014 & swave == 2 ~ 2014,
                             spanel == 2014 & swave == 3 ~ 2015, 
                             spanel == 2014 & swave == 4 ~ 2016, 
                             
                             spanel == 2018 & swave == 1 ~ 2017,
                             spanel == 2018 & swave == 2 ~ 2018,
                             spanel == 2018 & swave == 3 ~ 2019, 
                             spanel == 2018 & swave == 4 ~ 2020, 
                             
                             spanel == 2019 & swave == 1 ~ 2018,
                             
                             spanel == 2020 & swave == 1 ~ 2019,
                             spanel == 2020 & swave == 2 ~ 2020,
                             spanel == 2020 & swave == 3 ~ 2021, 
                             spanel == 2020 & swave == 4 ~ 2022,
                             
                             spanel == 2021 & swave == 1 ~ 2020,
                             spanel == 2021 & swave == 2 ~ 2021,
                             spanel == 2021 & swave == 3 ~ 2022,
                             
                             spanel == 2022 & swave == 1 ~ 2021,
                             spanel == 2022 & swave == 2 ~ 2022,
                             
                             spanel == 2023 & swave == 1 ~ 2022,
                             .default = NA),
         educ_fct = factor(case_when(eeduc >= 43 ~ "4-year Degree or More",
                              eeduc >= 40 ~ "Some College or Assoc",
                              eeduc < 40 ~ "HS or Less", 
                              .default = NA), levels = c("HS or Less", "Some College or Assoc", "4-year Degree or More")),
         industry_fct = case_when(ind < 570 ~ "Forestry, Farming, Fishing, Hunting, & Mining",
                                  ind == 770 ~ "Construction",
                                  ind >=1070 & ind <=3990 ~ "Manufacturing",
                                  ind >= 4070 & ind <= 4590 ~ "Wholesale Trade",
                                  ind >= 4670 & ind <= 5790 ~ "Retail Trade",
                                  (ind >=6070 & ind <= 6390) | (ind >= 570 & ind <= 690) ~ "Transportation, Warehousing & Utilities",
                                  ind >= 6470 & ind <= 6780 ~ "Information",
                                  ind >= 6870 & ind <= 7190 ~ "Finance and Insurance, and Real Estate, and Rental and Leasing",
                                  ind >= 7270 & ind <= 7790 ~ "Professional, Scientific, and Management, and Administrative, and Waste Management Services",
                                  ind >= 7860 & ind <= 8470  ~ "Educational Services, and Health Care and Social Assistance",
                                  ind >= 8560 & ind <= 8690 ~ "Arts, Entertainment, and Recreation, and Accommodation and Food Services",
                                  ind >= 8770 & ind <= 9290 ~ "Other Services, Except Public Administration",
                                  ind >= 9370 & ind <= 9590  ~ "Public Administration",
                                  ind >= 9890  ~ "Military",
                                  .default = NA), 
         parent = ifelse(epar_scrnr == 1, 1, 
                         ifelse(epar_scrnr == 2, 0, NA))
         
         
  )
```

Investigating inconsisent parent coding. Obviously someone could go from not being a parent to being a parent, but we have people go from being a parent to not being a parent, using either of the parent variables we have. Really we're probably interested in if they have a dependent child but we use this measure and impute forwards if someone ever reported having a child.

```{r}
temp <- long_wd %>% 
  arrange(ssuid_spanel_pnum, swave, monthcode) %>%  
  group_by(ssuid_spanel_pnum) %>% 
  mutate(parent_disappear = parent < first(parent)) %>% ungroup()

monthly %>% filter(ssuid_spanel_pnum == "114285465212021103") %>% select(swave, monthcode, tceb, epar_scrnr) # example of someone with inconsistent parent information within the base data. 

temp %>% group_by(parent_disappear) %>% distinct(ssuid_spanel_pnum) %>% count()
temp %>% filter(ssuid_spanel_pnum == "114285465212021103") %>% select(swave, monthcode, tceb, epar_scrnr, parent)
```

Continuing work from the last chunk

```{r}
temp <- long_wd %>% 
  arrange(ssuid_spanel_pnum, swave, monthcode) %>% 
  group_by(ssuid_spanel_pnum) %>% 
  mutate(parent_first = first(parent),
         parent_last = last(parent)) %>% 
  # as we saw above some people reported moving from being a parent to being a non-parent, so we can carry that forwards. This is similar to the tceb issue where people reported having biological children in an earlier wave and then report not occurring. Using the epar_scrnr this is 934 people with this disappearing child (could be due to deaths I suppose, but the question seems more general to did they ever have a kid. )
  mutate(parent_std= parent,
         parent_std = cummax(parent_std)) %>% ungroup()

temp %>% filter(ssuid_spanel_pnum == "114285465212021103") %>% select(swave, monthcode, tceb, epar_scrnr, contains("parent")) %>% print(n = 100)
temp %>% filter(ssuid_spanel_pnum == "2920924180182014101") %>% select(swave, monthcode, tceb, epar_scrnr, contains("parent")) %>% print(n = 100)

```

```{r imputing parental status}
long_wd <- long_wd %>% 
  arrange(ssuid_spanel_pnum, swave, monthcode) %>% 
  group_by(ssuid_spanel_pnum) %>% 
  mutate(parent_first = first(parent),
         parent_last = last(parent)) %>% 
  # as we saw above some people reported moving from being a parent to being a non-parent, so we can carry that forwards. This is similar to the tceb issue where people reported having biological children in an earlier wave and then report not occurring. Using the epar_scrnr this is 934 people with this disappearing child (could be due to deaths I suppose, but the question seems more general to did they ever have a kid. )
  mutate(parent_std= parent,
         parent_std = cummax(parent_std)) %>% ungroup() 
```

## Filtering to those with full years of data.

Representative examples to check, so this person 7178160572292014102 has 17 months in the data, and this person has three 8818607717842014104. We want to lose them both and end up with only those who we observe for a full 12 months in each wave.

```{r filtering to only those with full years of data}
full_year_markers <- long_wd %>% 
  group_by(ssuid_spanel_pnum, swave) %>% 
  # check that in each wave the person has a full 12 months. 
  summarize(has_full_year = all(1:12 %in% monthcode)) %>%
  ungroup() %>% 
  # filter to only those waves where a person had 12 months of data. 
  filter(has_full_year) 

full_year_markers %>% filter(ssuid_spanel_pnum %in% c("7178160572292014102", "8818607717842014104"))

# merge this in with only keeping the records that had full years of data. 
long_wd <- long_wd %>% inner_join(full_year_markers, by = c("ssuid_spanel_pnum", "swave")) %>% 
  # make a new months_in_data column now that we've removed partial waves
  select(-months_in_data) %>% 
  group_by(ssuid_spanel_pnum) %>% 
  mutate(months_in_data = n())

table(long_wd$months_in_data) # confirming we have full years for everyone at this point. 
```

## Creating Modal Y1 status

```{r function to find max mode}
find_max_mode <- function(x) {
  u <- unique(x)
  tab <- tabulate(match(x, u))
  max(u[tab == max(tab)]) 
}
```

```{r capturing first year status}
mode_statuses <- long_wd %>% select(ssuid_spanel_pnum, swave, monthcode, employment_type) %>% 
  arrange(ssuid_spanel_pnum, swave, monthcode) %>% 
  group_by(ssuid_spanel_pnum) %>% 
  filter(row_number() <=12) %>% 
  summarize(mode_status = find_max_mode(employment_type)) 

long_wd <- long_wd %>% 
  left_join(mode_statuses, by = "ssuid_spanel_pnum") # this adds their mode status during the first year to all records for the individual. 
```

## Measuring Y1 consecutive unemployment

```{r creating max_consec uneployment measure}
library(data.table)
consec_unemp <- setDT(long_wd)
consec_unemp <- consec_unemp %>% 
  group_by(ssuid_spanel_pnum) %>% 
  filter(row_number() <=12) %>% 
  mutate(
    ### Gen value of 1 for first run, 2 for second stretch but doesn't filter to only those that are unemployed months
    stretch = rleid(workless_month),
    stretch_workless = ifelse(workless_month == 1, stretch, NA ),
    is_non_missing = !is.na(stretch_workless), # could recode this with just referencing stretch_workless
    spell_id = cumsum(is_non_missing & lag(!is_non_missing, default = TRUE)), # Identify spell groups
    spell_length = ifelse(is_non_missing, ave(is_non_missing, ssuid_spanel_pnum, spell_id, FUN = cumsum), 0),
    max_consec_unemp = max(spell_length, na.rm=TRUE)) %>%
  ungroup()


# checking it captured people correctly. 
consec_unemp %>% select(ssuid_spanel_pnum, swave, monthcode, employment_type, 
                workless_month, stretch, stretch_workless, is_non_missing,
                spell_id, spell_length, max_consec_unemp) %>% filter(ssuid_spanel_pnum %in% c("1288929322014101", "1142851342014103", "292418136626182018102")) %>% select(ssuid_spanel_pnum, monthcode, employment_type, workless_month, max_consec_unemp) %>% print(n = 100)

consec_unemp <- consec_unemp %>% 
  group_by(ssuid_spanel_pnum) %>% 
  summarize(max_consec_unemp = first(max_consec_unemp, na.rm = TRUE))
```

```{r merging in unemployment streak measure  }
long_wd <- long_wd %>% 
  left_join(consec_unemp, by = "ssuid_spanel_pnum")
```

```{r filtering out those who started out as other employment as modal status}
long_wd <- long_wd %>% 
  group_by(ssuid_spanel_pnum) %>% 
  tidylog::filter(!any(mode_status == 3)) %>% 
  tidylog::filter(!any(industry_fct == "Military", na.rm = TRUE)) %>% 
  ungroup()

```

```{r replicating y1_status_v2 from stata script}
# Take our modal status, but override the mode if someone experienced 3 or more months of unemployment during first year in the data. 
y1_statuses <- long_wd %>% 
  select(ssuid_spanel_pnum, swave, monthcode, employment_type, workless_month, mode_status) %>% 
  arrange(ssuid_spanel_pnum, swave, monthcode) %>% 
  group_by(ssuid_spanel_pnum) %>% 
  filter(row_number() <=12) %>%  # keep each person's first year only. 
  summarize(unemp_f12 = sum(workless_month, na.rm = TRUE),
            mode_status = first(mode_status)) %>%
  ungroup() %>% 
  mutate(y1_status_v2 = ifelse(unemp_f12 >=3, 4,
                                  mode_status)) 

```

```{r}
long_wd <- long_wd %>% 
  left_join(y1_statuses %>% select(ssuid_spanel_pnum, y1_status_v2, unemp_f12), by = "ssuid_spanel_pnum")
```

```{r dropping those we only have one year of data on}
long_wd <- long_wd %>% 
  filter(months_in_data > 12 ) ## really only == 12 here since we've already filterd to only thsoe with full years.
```

```{r}
se_quantified <- long_wd %>% 
  arrange(ssuid_spanel_pnum, swave, monthcode) %>% 
  group_by(ssuid_spanel_pnum) %>%
   # get only records after first year
  filter(row_number() > 12) %>% 
  summarize(ft_se_months_py1 = sum(ifelse(mwkhrs >= 15 & employment_type == 2,1,0), na.rm = TRUE),
         pt_se_months_py1 = sum(ifelse(mwkhrs < 15 & employment_type == 2,1,0), na.rm = TRUE),
         pt_months_py1 = sum(ifelse(mwkhrs < 15,1,0), na.rm = TRUE),
         ft_months_py1 = sum(ifelse(mwkhrs >= 15, 1, 0), na.rm = TRUE),
         ft_ws_months_py1 = sum(ifelse(mwkhrs >=15 & employment_type == 1,1,0), na.rm = TRUE),
         pt_ws_months_py1 = sum(ifelse(mwkhrs < 15 & employment_type == 1,1,0), na.rm = TRUE),
         months_after_y1 = max(row_number()),
         pct_se_py1_ft = ft_se_months_py1/months_after_y1,
         months_employed = sum(ifelse(employment_type != 4,1,0)),
         mean_hrs = mean(mwkhrs, na.rm = TRUE),
         ) %>% 
  ungroup()



```

```{r}
almost_ft <- se_quantified %>% filter(months_after_y1 != ft_months_py1) %>% select(ssuid_spanel_pnum) %>% as.vector()
## confirming here that these people are actually correctly coded
joblevel_wide %>% filter(ssuid_spanel_pnum %in% almost_ft$ssuid_spanel_pnum) %>% 
  select(
  ssuid_spanel_pnum,
  swave,
  monthcode,
  contains("msum"),
  contains("mwkhrs"),
  -contains("alt"),
  contains("jborse")
) %>% 
  View()




temp <- long_wd %>% 
  left_join(se_quantified, by = "ssuid_spanel_pnum") %>% 
  group_by(ssuid_spanel_pnum) %>% 
  filter(row_number()>12) %>% 
  ungroup() %>% 
  # based on the number of people we lose here I think we actually want to allow some flexibility here. 
  tidylog::filter(months_after_y1 != ft_months_py1)


temp %>% select(ssuid_spanel_pnum, swave, monthcode, months_in_data, months_after_y1, ft_months_py1, months_employed, workless_month, enjflag_std, jobid, msum, mwkhrs) %>% View()
```

Slight discrepancy here for enjflag vs workless_month definition.

![](images/clipboard-1155767985.png)

What do we do about the people like ssuid_spanel_pnum == "292092406784182018101" who are in our data for 48 months, and we use their first year to establish their status, then during the following 36 months, we previously would've lost them due to their work-hours not always being \>= 15. But for this person, that decrease in work hours is only for one month. In other words, for 35 out of 36 months we're looking at their earnings they have a full-time job but only one where they work fewer than 15 hours.

**Filter to only those with months_employed == months_after_y1, then filter to those with se as \>.5 percent of the months after that and then to account for side-hustles filter to their mean working hours as \>15.**

```{r}
se_quantified %>% filter(ssuid_spanel_pnum == "292092406784182018101")
```

```{r}
table(temp$ft_months_py1, temp$months_after_y1)
```

```{r cleanup missings}
analysis_df <- long_wd %>%
  tidylog::filter(if_all(
    c(
      ssuid_spanel_pnum,
      swave,
      spanel,
      monthcode,
      race_eth_fct_cpsd,
      sex_fct,
      immig_fct,
      calyear,
      educ_fct,
      industry_fct,
      parent_std,
      unemp_f12,
      y1_status_v2,
      mode_status,
      max_consec_unemp,
      employment_type
    ),
    ~ !is.na(.)
  )) %>%
  tidylog::filter(!is.na(msum) & workless_month != 1) %>% 
  tidylog::filter(!is.na(tpearn) & workless_month != 1) 
```

```{r}

```

To-dos: - look at annual earnings - test descriptives with weights included - look at regressions, - test regressions with weights included
